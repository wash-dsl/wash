<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File Explorer5.java &mdash; Python  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Program Listing for File Explorer5.java</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File Explorer5.java</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer5.java.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-explorer5-java">
<span id="program-listing-file-mnt-c-users-scott-onedrive-documents-offline-work-backups-cs118-robot-coursework-explorer5-java"></span><h1>Program Listing for File Explorer5.java<a class="headerlink" href="#program-listing-for-file-explorer5-java" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer5.java.html#file-mnt-c-users-scott-onedrive-documents-offline-work-backups-cs118-robot-coursework-explorer5-java"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">/mnt/c/Users/scott/OneDrive/Documents/Offline</span> <span class="pre">Work/Backups/CS118</span> <span class="pre">Robot</span> <span class="pre">Coursework/Explorer5.java</span></code>)</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.logic.IRobot</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.ArrayList</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Random</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.HashMap</span><span class="p">;</span><span class="w"></span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Explorer</span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pollRun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">RobotData</span><span class="w"> </span><span class="n">robotData</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">explorerMode</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">controlRobot</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>

<span class="w">        </span><span class="n">initRobotData</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Creates the RobotData class if this is the first run</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">directionToMove</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">CalculateReverseOfHeading</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">WEST</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">explorerMode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">directionToMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exploreControl</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">directionToMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">backtrackControl</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">robot</span><span class="p">.</span><span class="na">face</span><span class="p">(</span><span class="n">directionToMove</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">exploreControl</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"> </span><span class="c1">//Returns the direction the robot should move in based on how many exits surround the robot</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonWallExits</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Calculate number of exits</span><span class="w"></span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">numExits</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">(</span><span class="n">moveDeadEnd</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//moveDeadEnd returns the direction to move. This is returned to the main controlRobot subroutine</span><span class="w"></span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">(</span><span class="n">moveCorridor</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//moveCorridor returns the direction to move</span><span class="w"></span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">DoRecordJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//As the robot has reached a junction, record the junction data in the Robot Data class</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">(</span><span class="n">moveJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//moveJunction returns the direction to move</span><span class="w"></span>
<span class="w">            </span><span class="k">default</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="n">DoRecordJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">(</span><span class="n">moveCrossroads</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//moveCrossroads returns the direction to move</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">backtrackControl</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonWallExits</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Calculate number of exits</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numPassageExits</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">numExits</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">){</span><span class="w"> </span><span class="c1">//Robot at junction or crossroad</span><span class="w"></span>
<span class="w">            </span><span class="n">numPassageExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">passageExits</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numPassageExits</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">exploreControl</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Call the explorer control function, as back in explorer mode</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="p">{</span><span class="w"> </span><span class="c1">//Exit the junction the opposite way that the robot entered</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">CalculateReverseOfHeading</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">heading</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//If travelling south the robot would have arrived from north, so add 2 to the heading arrived from</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Then moduli 4 as there are 4 directions. Otherwise e.g. IRobot.WEST + 2 would not result in a valid direction.</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">NORTH</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">heading</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">initRobotData</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">((</span><span class="n">robot</span><span class="p">.</span><span class="na">getRuns</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pollRun</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"> </span><span class="c1">//Only create a robot data class if this is the first run and the first time controlRobot has been polled</span><span class="w"></span>
<span class="w">            </span><span class="n">robotData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RobotData</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//Robot starts in explorer mode</span><span class="w"></span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Creating the RobotData class&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">pollRun</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//Increment the pollRun variable to avoid a new RobotData class being created next poll.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>


<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DoRecordJunction</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">beenbeforeExits</span><span class="p">(</span><span class="n">robot</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">){</span><span class="w"> </span><span class="c1">//If been before exit &lt;= 1 , the junction is unexplored</span><span class="w"></span>
<span class="w">            </span><span class="n">robotData</span><span class="p">.</span><span class="na">RecordJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Only record junction if the junction is unexplored</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">nonWallExits</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//returns the number of non-WALL squares adjacent to the square currently occupied.</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Iterates through each relative direction</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"> </span><span class="c1">//For each direction, check if an exit lies ahead</span><span class="w"></span>
<span class="w">                </span><span class="n">numExits</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//If an exit lies ahead, increment the number of exits</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">numExits</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">beenbeforeExits</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//returns the number of non-WALL squares adjacent to the square currently occupied.</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numBeenBefore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Iterate through each direction</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">BEENBEFORE</span><span class="p">){</span><span class="w"> </span><span class="c1">//For each direction, check if the robot has been there before</span><span class="w"></span>
<span class="w">                </span><span class="n">numBeenBefore</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//Increment if robot has been there before</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">numBeenBefore</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">passageExits</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//returns the number of passage squares adjacent to the square currently occupied.</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numPassageExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Iterate through each direction</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">PASSAGE</span><span class="p">){</span><span class="w"> </span><span class="c1">//For each direction, check if there is a passage</span><span class="w"></span>
<span class="w">                </span><span class="n">numPassageExits</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//Increment if there is a passage</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">numPassageExits</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">moveDeadEnd</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*Check each direction for the exit</span>
<span class="cm">        Cannot just reverse direction, as robot could be facing any direction</span>
<span class="cm">        at the start*/</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Iterate through each direction</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"> </span><span class="c1">//Find the direction that will not cause a collision</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;unreachable code reached in moveDeadEnd&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*As there should always be an exit that the robot can travel down at a dead end,</span>
<span class="cm">        this error can only occur if there has been a fatal error in the maze environment*/</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">moveCorridor</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Check all directions apart from behind. Robot should not reverse direction when travelling along a corridor</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">BEHIND</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;unreachable code reached in moveCorridor&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*As there should always be &gt;= 1 exit that the robot can travel down in a corridor,</span>
<span class="cm">        this error can only occur if there has been a fatal error in the maze environment*/</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">moveJunction</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nonWallExitsList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">passagesList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">//List of the passages that the robot has not yet been explored</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pathType</span><span class="p">;</span><span class="w"> </span><span class="c1">//e.g. IRobot.BEENBEFORE or IRobot.PASSAGE</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">pathType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">pathType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">PASSAGE</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">passagesList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">pathType</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">nonWallExitsList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">passagesList</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">chooseRandomExit</span><span class="p">(</span><span class="n">passagesList</span><span class="p">));</span><span class="w"> </span><span class="c1">//Choose a random exit out of all the passages</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"> </span><span class="c1">//If there are no unexplored passages, pick a random exit from all the nonWallExits.</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">chooseRandomExit</span><span class="p">(</span><span class="n">nonWallExitsList</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">chooseRandomExit</span><span class="p">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="n">exitList</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Returns a random element of the exit array</span><span class="w"></span>
<span class="w">        </span><span class="n">Random</span><span class="w"> </span><span class="n">rand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Random</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">(</span><span class="n">exitList</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">rand</span><span class="p">.</span><span class="na">nextInt</span><span class="p">(</span><span class="n">exitList</span><span class="p">.</span><span class="na">size</span><span class="p">())));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">moveCrossroads</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">(</span><span class="n">moveJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*Currently move junction and move crossroads can be achieved</span>
<span class="cm">        with the same method*/</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">reset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">robotData</span><span class="p">.</span><span class="na">resetJunctionCounter</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//Reset explorerMode so that the robot will be in explore mode next run.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">class</span> <span class="nc">RobotData</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hashMapHeadings</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">junctionCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Represents the last index of the erray</span><span class="w"></span>
<span class="w">    </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">JunctionRecorder</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arrayOfJunctionRecorders</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*I chose an arrayList to hold the junctionRecorders, as new junctionRecoders are being added with every junction that is found.</span>
<span class="cm">    If an array with 10,000 max junctions were used (as in the guide), there would typically be a large amount of wasted space in the array,</span>
<span class="cm">    as it is very unlikely that the number of junctions encountered would reach near 10,000. */</span><span class="w"></span>

<span class="w">    </span><span class="n">RobotData</span><span class="p">(){</span><span class="w"> </span><span class="c1">//Class Constructor</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">arrayOfJunctionRecorders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">JunctionRecorder</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">CreateHashMap</span><span class="p">();</span><span class="w"> </span><span class="c1">//Create the hashMap for headings.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">RecordJunction</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">arrayOfJunctionRecorders</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">JunctionRecorder</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">getLocation</span><span class="p">().</span><span class="na">x</span><span class="p">,</span><span class="n">robot</span><span class="p">.</span><span class="na">getLocation</span><span class="p">().</span><span class="na">y</span><span class="p">,</span><span class="n">robot</span><span class="p">.</span><span class="na">getHeading</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Add a new junctionRecorder to the ArrayList, passing in the coordinates and heading of the robot as the properties of the junction.</span><span class="w"></span>

<span class="w">        </span><span class="n">printJunction</span><span class="p">(</span><span class="n">junctionCounter</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">junctionCounter</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">resetJunctionCounter</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="n">junctionCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Reset the index of the arraylist to 0</span><span class="w"></span>
<span class="w">        </span><span class="n">arrayOfJunctionRecorders</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span><span class="w"> </span><span class="c1">//Remove all items from the collection.</span><span class="w"></span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Resetting junction counter&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">printJunction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">indexOfJunctionRecorder</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">JunctionRecorder</span><span class="w"> </span><span class="n">CurrentJunctionRecorder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arrayOfJunctionRecorders</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">indexOfJunctionRecorder</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">CurrentJuncX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CurrentJunctionRecorder</span><span class="p">.</span><span class="na">getJuncX</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">CurrentJuncY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CurrentJunctionRecorder</span><span class="p">.</span><span class="na">getJuncY</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">CurrentHeadingArrivedFrom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hashMapHeadings</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">CurrentJunctionRecorder</span><span class="p">.</span><span class="na">getHeadingArrived</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Uses the hashmap to converting headings to strings e.g. IRobot.NORTH --&gt; &#39;NORTH&#39;</span><span class="w"></span>

<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">printf</span><span class="p">(</span><span class="s">&quot;Junction %d (x=%d,y=%d) heading %s \n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">indexOfJunctionRecorder</span><span class="p">,</span><span class="n">CurrentJuncX</span><span class="p">,</span><span class="n">CurrentJuncY</span><span class="p">,</span><span class="n">CurrentHeadingArrivedFrom</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">CreateHashMap</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="n">hashMapHeadings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="p">(){</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">NORTH</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NORTH&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">EAST</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;EAST&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">SOUTH</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SOUTH&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">WEST</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WEST&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">searchJunction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">juncX</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">juncY</span><span class="p">){</span><span class="w"> </span><span class="c1">//Returns heading of robot when the junction was first encountered</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Search through array of junction recorders, starting at the most recently encountered junctions.</span><span class="w"></span>
<span class="w">        </span><span class="c1">//The junction is more likely to be at the end of the list so start there and iterate back through the array</span><span class="w"></span>

<span class="w">        </span><span class="n">JunctionRecorder</span><span class="w"> </span><span class="n">juncToCompare</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">arrayOfJunctionRecorders</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">juncToCompare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arrayOfJunctionRecorders</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">juncToCompare</span><span class="p">.</span><span class="na">getJuncX</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">juncX</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">juncToCompare</span><span class="p">.</span><span class="na">getJuncY</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">juncY</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">juncToCompare</span><span class="p">.</span><span class="na">getHeadingArrived</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;unreachable code reached in searchJunction (no junction found)&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*If in backtracking mode and the robot reaches a junction, it should be in the list of encountered junctions.</span>
<span class="cm">        So if no junction can be found in the arrayList, even though the robot should have visited it before, a serious error has occured*/</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">class</span> <span class="nc">JunctionRecorder</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">juncX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">juncY</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">headingArrived</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">JunctionRecorder</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">headingArrived</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">setJunctionLocation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">setHeadingArrived</span><span class="p">(</span><span class="n">headingArrived</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setJunctionLocation</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">juncX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">juncY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setHeadingArrived</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">heading</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">headingArrived</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heading</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getJuncX</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">juncX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getJuncY</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">juncY</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getHeadingArrived</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">headingArrived</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>