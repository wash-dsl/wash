
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Coursework_2_complete_Ex3.java:

Program Listing for File Ex3.java
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Coursework_2_complete_Ex3.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Complete Exercises/Coursework 2 complete/Ex3.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   /*Ex3 Preamble: To create a robot that can solve loopy mazes, only a few minor modifications to my solution for Ex1 were required.
   My solutions for Ex1 and Ex2 rely on the fact that, once all exits at a junction have been explored, that junction will never be visited again
   once it has been backtracked through. However, with loops, a junction may be visited again, even if all the exits are BEENBEFORE. This can break
   my program, as the robot will occasionally get stuck in an infinite loop around a small section of the maze.
   
   In Prim-Generated mazes, if the robot reaches a junction with only one BEENBEFORE exit, then it has reached a previously unencountered junction.
   However, this method for detecting new junctions can fail in loopy mazes, as there can be multiple BEENBEFORE exits when a robot encounters a
   junction for the first time.
   
   To correct these problems in Ex3, if the robot finds a loop (by reaching a square while exploring where all exits are BEENBEFORE), the robot
   will reverse direction, and go back up the corridor it came from. This means that the robot treats loops as new walls, effectively turning a
   maze with loops back into a Prim-Generated maze, which can be represented as a tree. Furthermore, instead of checking for a new junction by
   examining the number of BEENBEFORE exits, Ex3 corrects the second problem by using searchJunction() to check if the junction exists in the
   array of junction recorders. 
   */
   
   
   import uk.ac.warwick.dcs.maze.logic.IRobot;
   import java.util.ArrayList;
   import java.util.Random;
   import java.util.HashMap;
   import java.awt.Point;
   
   public class Ex3{
   
       private int pollRun = 0;
       private RobotData robotData;
       private boolean explorerMode;
   
       public void controlRobot(IRobot robot){
           int directionToMove;
   
           initRobotData(robot); //Creates the RobotData class if this is the first run
   
           if (explorerMode == true){ //If explore mode on, call the exploreControl subroutine.
               directionToMove = exploreControl(robot);
           }
           else{
               directionToMove = backtrackControl(robot);
           }
   
           robot.face(directionToMove);
       }
   
       private void initRobotData(IRobot robot){
           if(pollRun == 0){
               explorerMode = true; //Robot starts in explorer mode
               if((robot.getRuns() == 0)){ //Only create a robot data class if this is the first run and the first time controlRobot has been polled this run
                   robotData = new RobotData();
                   System.out.println("Creating the RobotData class");
               }
           }
           pollRun++; //Increment the pollRun variable to avoid a new RobotData class being created next poll.
       }
   
   
       private int exploreControl(IRobot robot){ //Returns the direction the robot should move in based on how many exits surround the robot
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           switch (numExits){
               case 1:
                   if(pollRun > 1){ //Only set to backtrack if not at the start of maze. If started at a dead end, still should be in explore mode.
                       explorerMode = false;
                   }
                   return(moveDeadEnd(robot)); //moveDeadEnd returns the direction to move. This is returned to the main controlRobot subroutine
               case 2:
                   return(moveCorridorExplorer(robot));
               default: //Moving at crossroads (4 exits) and at junctions (3 exits) can be executed by the same code
                   doRecordJunction(robot); //As the robot has reached a junction, record the junction data in the Robot Data class
                   return(moveJunctionExplorer(robot));
           }
       }
   
       private int backtrackControl(IRobot robot){
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           if(numExits > 2){ //Robot at junction or crossroad
   
               return(backtrackAtJunctionCrossroads(robot));
           }
           else{ //If there are less than or equal to 2 exits, we can just use the exploreControl to select the appropriate move for at a dead end / corridor.
               return backtrackAtDeadEndJunction(robot, numExits);
           }
       }
   
       private int backtrackAtJunctionCrossroads(IRobot robot){ //Handles the backtracking if the robot is at a junction or at crossroads.
           int numPassageExits = calcNumExits(robot,IRobot.PASSAGE); //Calculate the number of passage exits.
   
           if (numPassageExits > 0){ //If there is an unexplored passage, switch back into explorer mode.
               explorerMode = true;
               return(exploreControl(robot)); //Call the explorer control function to determine the move, as explorer mode has been activated
           }
           else{ //Exit the junction the opposite way that the robot entered
               return(exitJunctionReverse(robot));
           }
       }
   
       private int backtrackAtDeadEndJunction(IRobot robot, int numExits){
           if(numExits == 2){
               return(moveCorridor(robot));
           }
           else{
               return(moveDeadEnd(robot));
           }
       }
   
       private int exitJunctionReverse(IRobot robot){ //Exit the junction the opposite way to which the robot was heading when it found the junction the first time.
           int headingEnteredJunction = robotData.searchJunction(robot.getLocation()).getHeadingArrived(); //Search each junction recorder for data about the junction at the robot's current position.
           return(moveReverse(robot, headingEnteredJunction));
       }
   
       private int moveReverse(IRobot robot, int heading){ //Takes a heading and returns the reverse of that heading. Return value is a relative direction
           explorerMode = false; //As reversing direction,
           return(convertHeadingToRelativeDirection(robot,calculateReverseOfHeading(heading))); //Go back
       }
   
       private int calculateReverseOfHeading(int heading){
           return (IRobot.NORTH + (heading + 2) % 4); //If travelling south the robot would have arrived from north, so add 2 to the heading arrived from
           //Moduli 4 as there are 4 directions. Otherwise e.g. IRobot.WEST + 2 would not result in a valid direction.
       }
   
       private int convertHeadingToRelativeDirection(IRobot robot, int heading){
           int difference = heading - robot.getHeading(); //get the difference between current heading and the heading to look
           int relativeDirection = IRobot.AHEAD + (IRobot.AHEAD + difference) % 4;
           //Calculate the relative direction by adding the difference to IRobot.AHEAD. Modulo 4 as there are 4 directions.
           return relativeDirection;
       }
   
       private void doRecordJunction(IRobot robot){
           if(robotData.searchJunction(robot.getLocation()) == null){ //If not in the array
               robotData.recordJunction(robot); //Only record junction if the junction is unexplored
           }
       }
   
       private int nonWallExits(IRobot robot){ //returns the number of non-WALL squares adjacent to the square currently occupied.
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterates through each relative direction
               if(robot.look(direction) != IRobot.WALL){ //For each direction, check if an exit lies ahead
                   numExits++; //If an exit lies ahead, increment the number of exits
               }
           }
           return numExits;
       }
   
       private int calcNumExits(IRobot robot, int exitType){ //Pass in an exit type and it calculates how many exits of that type are around the robot
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) == exitType){ //For each direction, check if there is a path matching exitType
                   numExits++; //Increment if there is a matching path.
               }
           }
           return numExits;
       }
   
       private int moveDeadEnd(IRobot robot){
           //Check each direction for the exit. Cannot just reverse direction, as robot could be facing any direction at the start
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collision
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveDeadEnd");
           /*As there should always be an exit that the robot can travel down at a dead end,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveCorridorExplorer(IRobot robot){ //Handles moving along corridors when exploring
           if(calcNumExits(robot, IRobot.PASSAGE) == 0)
           { //If there are no passages along a corridor, have found a loop, so reverse direction.
               return(moveReverse(robot, robot.getHeading()));
           }
           else{
               return(moveCorridor(robot));
           }
       }
   
       private int moveCorridor(IRobot robot){ //Finds the only exit that is not behind the robot.
           //Check all directions apart from behind. Robot should not reverse direction when travelling along a corridor
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               if(direction != IRobot.BEHIND && robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collisin
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveCorridor");
           /*As there should always be >= 1 exit that the robot can travel down in a corridor,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveJunctionExplorer(IRobot robot){ //Handles moving at junctions when exploring
           if (calcNumExits(robot, IRobot.PASSAGE) == 0){ //If there are no passages at a junction, must have found a loop.
               return(moveReverse(robot, robot.getHeading())); //Reverse direction and head back
           }
           else{
               return(moveJunction(robot));
           }
       }
   
       private int moveJunction(IRobot robot){
           ArrayList<Integer> nonWallExitsList = new ArrayList<Integer>();
           ArrayList<Integer> passagesList = new ArrayList<Integer>();
           //List of the passages that the robot has not yet been explored
   
           int pathType; //e.g. IRobot.BEENBEFORE or IRobot.PASSAGE
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               pathType = robot.look(direction); //Get the type of path at the current direction.
   
               if(pathType == IRobot.PASSAGE){ //If the path is a passage add it to passages list
                   passagesList.add(direction);
               }
               else if(pathType != IRobot.WALL){ //If the path is an exit add it to the nonWallExitsList
                   nonWallExitsList.add(direction);
               }
           }
           if(passagesList.size()>0){ //If there is a passage exit:
               return(chooseRandomExit(passagesList)); //Choose a random exit out of all the passages and return that direction
           }
           else{ //If there are no unexplored passages, pick a random exit from all the nonWallExits.
               return(chooseRandomExit(nonWallExitsList));
           }
       }
   
       private int chooseRandomExit(ArrayList<Integer>exitList){
           //Takes in an array and returns a random element in that array.
           Random rand = new Random();
           return(exitList.get(rand.nextInt(exitList.size()))); //Chooses a random index from 0 to the (length of the array - 1)
       }
   
       public void reset() {
           robotData.resetJunctionCounter();
           explorerMode = true; //Reset explorerMode so that the robot will be in explore mode next run.
           pollRun = 0; //Reset the number of polls this run.
       }
   }
   
   class RobotData{
       private HashMap<Integer, String> hashMapHeadings; //Used to convert headings to strings. IRobot.SOUTH -> 'SOUTH'
       private int junctionCounter = 0; //Represents the last index of the ArrayList
       ArrayList<JunctionRecorder> arrayOfJunctionRecorders;
       /*I chose an arrayList to hold the junctionRecorders, as new junctionRecoders are being added with every junction that is found.
       If an array with 10,000 max junctions were used (as in the guide), there would typically be a large amount of wasted space in the array,
       as it is very unlikely that the number of junctions encountered would reach near 10,000. */
   
       RobotData(){ //Class Constructor
           this.arrayOfJunctionRecorders = new ArrayList<JunctionRecorder>();
           createHeadingsHashMap(); //Create the hashMap for headings.
       }
   
       public void recordJunction(IRobot robot){
           this.arrayOfJunctionRecorders.add(new JunctionRecorder(robot.getLocation(),robot.getHeading()));
           //Add a new junctionRecorder to the ArrayList, passing in the coordinates and heading of the robot as the properties of the junction.
           printJunction(junctionCounter); //print the details of the newly encountered junction
           junctionCounter++; //Increment the junction counter for when another junction is encountered.
       }
   
       public void resetJunctionCounter(){
           junctionCounter = 0; //Reset the index of the arraylist to 0
           arrayOfJunctionRecorders.clear(); //Remove all items from the collection.
           System.out.println("Resetting junction counter");
       }
   
       private void printJunction(int indexOfJunctionRecorder){
           JunctionRecorder CurrentJunctionRecorder = arrayOfJunctionRecorders.get(indexOfJunctionRecorder);
           //Get the junction recorder specifies by the indexOfJunctionRecorder paramter
   
           int CurrentJuncX = CurrentJunctionRecorder.getLocation().x;
           int CurrentJuncY = CurrentJunctionRecorder.getLocation().y;
           String CurrentHeadingArrivedFrom = hashMapHeadings.get(CurrentJunctionRecorder.getHeadingArrived());
           //Uses the hashmap to converting headings to strings e.g. IRobot.NORTH --> 'NORTH'
   
           System.out.printf("Junction %d (x=%d,y=%d) heading %s \n", indexOfJunctionRecorder,CurrentJuncX,CurrentJuncY,CurrentHeadingArrivedFrom);
       }
   
       private void createHeadingsHashMap(){
           hashMapHeadings = new HashMap<Integer, String>(){ //Creates a hashmap with integers as the key (e.g. IRobot.NORTH) and string as the value (e.g. 'NORTH')
               {
                   put(IRobot.NORTH, "NORTH");
                   put(IRobot.EAST, "EAST");
                   put(IRobot.SOUTH, "SOUTH");
                   put(IRobot.WEST, "WEST");
               }
           };
       }
   
       public JunctionRecorder searchJunction(Point juncLocation){ //Returns data about the requested junction, if it has been found.
           //Search through array of junction recorders, starting at the most recently encountered junctions.
           //The junction is more likely to be at the end of the list so start there and iterate back through the array
           JunctionRecorder juncToCompare;
   
           for (int i = this.arrayOfJunctionRecorders.size()-1; i >= 0; i--) { //Iterates through each junction starting with most recently encountered
               juncToCompare = arrayOfJunctionRecorders.get(i);
               if (juncToCompare.getLocation().equals(juncLocation))  {//If the X and Y coordinates match. Use of .equals to check the values inside not object, not the object itself.
                   return juncToCompare; //Return the data about the junction.
               }
           }
   
           return null; //If no junctions could be found, return null
       }
   }
   
   class JunctionRecorder{ //Holds data for one junction that the robot has encountered
       private Point juncLocation; //X and Y of the junction stored in one point variable
       private int headingArrived;
   
       JunctionRecorder(Point _juncLocation, int _headingArrived){ //Constructor function takes in the x and y of the junction, along with the heading the robot arrived at.
           this.setJunctionLocation(_juncLocation);
           this.setHeadingArrived(_headingArrived);
       }
   
       private void setJunctionLocation(Point location){
           this.juncLocation = location;
       }
   
       private void setHeadingArrived(int heading){
           this.headingArrived = heading;
       }
   
       //The following subroutines are public as they will be accessed from the RobotData class.
       public Point getLocation(){
           return juncLocation;
       }
   
       public int getHeadingArrived(){
           return headingArrived; //Get the heading that the robot first arrived at the junction
       }
   }
