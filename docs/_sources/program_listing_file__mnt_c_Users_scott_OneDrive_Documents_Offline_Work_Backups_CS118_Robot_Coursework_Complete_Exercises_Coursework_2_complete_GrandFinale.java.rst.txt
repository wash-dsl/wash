
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Coursework_2_complete_GrandFinale.java:

Program Listing for File GrandFinale.java
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Coursework_2_complete_GrandFinale.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Complete Exercises/Coursework 2 complete/GrandFinale.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   /* Grand Finale Preamble: For the Grand Finale, I decided to modify my code for Ex2, as only a few small modifications were needed,
   so that the robot could record the fastest route. This means my robot uses a method very similar to Route B as described in the guide.
   
   In addition to my solution for Ex2, my program uses another stack to record the heading that the robot left each junction. When the
   robot arrives at a previously unencountered junction, the robot pushes the next chosen heading to the top of the stack.
   If a junction is backtracked through, that junction is not part of the final route to the target (as all of its exits have been
   explored), so the corresponding heading is popped from the top of the stack.
   
   I added a retraceControl method, that handles movement on repeat runs of the same maze. The method simply gets each heading in
   the finalRouteStack sequentially, and uses that to direct the robot straight to the target using the quickest route.
   
   To deal with new mazes, I used the IEvent and EventBus libraries so that my controller can receive events from the maze environment
   itself. When a new maze is loaded in, the EventClient class can receive event codes from the notify function. Each button in the maze
   environment sends a different code, so if an event is received and the event message is 115, for example, then a new maze has
   been loaded in from a file. Upon a new maze being loaded in, my program clears the junctionStack and the finalRoute stack, and
   resets all the variables.
   
   Like my solution for Ex2, my robot does not reliably solve loopy mazes. As junctions can be visited multiple times when the robot
   goes round a loop, the headings are not properly ejected from the stack, as the robot does not always backtrack through the junction. Therefore,
   if the user selects a generator that creates mazes with loops, I output a message to the console telling the user that this ‘controller
   does not find the quickest route in mazes with loops’. I used the EventBus again to detect when a new generator is selected, and
   compare the name of the new generator to a list of disallowedGenerators. If the new Generator is in this list, I output the warning
   message to the user.
   */
   
   import uk.ac.warwick.dcs.maze.logic.IRobot;
   import java.util.ArrayList;
   import java.util.Random;
   import java.util.HashMap;
   import java.util.Set;
   import uk.ac.warwick.dcs.maze.logic.IEventClient; //Import the Event libraries so that the controller can receive events from the maze environment
   import uk.ac.warwick.dcs.maze.logic.IEvent;
   import uk.ac.warwick.dcs.maze.logic.Event;
   import uk.ac.warwick.dcs.maze.logic.EventBus;
   import uk.ac.warwick.dcs.maze.logic.IMazeGenerator;
   import uk.ac.warwick.dcs.maze.generators.*; //Import maze.generators so that the program can check if the user has selected a loopy generator
   
   public class GrandFinale{
   
       private int pollRun = 0;
       private RobotData robotData;
       private boolean explorerMode;
       private boolean atJunction; //If the robot is at a junction, record the heading chosen.
       private boolean retrace; //Is the robot retracing for repeat run of the same maze
       private int retraceIndex = 0; //Represents the current index of the finalRouteStack (used for repeat runs of the same maze)
       private EventClient eventClient; //Class used to receive events from the maze environment through the EventBus.
   
   
       public void controlRobot(IRobot robot){
           int directionToMove;
   
           initRobotData(robot); //Creates the RobotData class if this is the first run
   
           if(retrace){
               directionToMove = retraceControl(robot);
           }
           else{
               directionToMove = explorerAndBacktrackControl(robot);
           }
   
           if(atJunction){ //If the robot is at a junction, record the heading that was chosen in the final route stack.
               recordFinalRouteHeading(robot, directionToMove);
           }
   
           robot.face(directionToMove);
       }
   
   
       private int explorerAndBacktrackControl(IRobot robot){ //Controls explorerControl and backtrackControl
           if (explorerMode == true){ //If explore mode on, call the exploreControl subroutine.
               return(exploreControl(robot));
           }
           else{
               return(backtrackControl(robot));
           }
       }
   
       private void initRobotData(IRobot robot){
           int numRuns = robot.getRuns();
   
           if(pollRun == 0){
               explorerMode = true; //Robot starts in explorer mode
               if((numRuns == 0)){ //Only create a robot data class if this is the first run and the first time controlRobot has been polled this run
                   robotData = new RobotData();
                   initEventBus(); //init event bus if this is the first run
                   System.out.println("Creating the RobotData class");
               }
           }
   
           if(numRuns > 0){
               retrace = true; //if this is the first run
           }
   
           pollRun++; //Increment the pollRun variable to avoid a new RobotData class being created next poll.
       }
   
       private void initEventBus(){
           if(eventClient == null){ //Only initialise the event client if the eventClient variable is empty
               System.out.println("Inialising event bus");
               eventClient = new EventClient(this); //Creates a new client
               EventBus.addClient(eventClient); //Adds this newly created client to the event bus, so my controller can receive notifications.
           }
   
       }
   
       private int retraceControl(IRobot robot){
           int numExits = nonWallExits(robot); //Calculate number of exits
           if(numExits <=2){
               return(exploreControl(robot)); //If at a deadend/corridor simply use exploreControl to determine the valid exit
           }
           else{
               int directionToMove = convertHeadingToRelativeDirection(robot, robotData.retraceGetNextHeading(retraceIndex));
               // directionToMove is the next heading in the stack converted to a relative direction
               retraceIndex++; //increment the retrace index to look at the next index in the finalRouteStack
               return(directionToMove);
           }
   
       }
   
       private int exploreControl(IRobot robot){ //Returns the direction the robot should move in based on how many exits surround the robot
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           switch (numExits){
               case 1:
                   if(pollRun > 1){ //Only set to backtrack if not at the start of maze. If started at a dead end, still should be in explore mode.
                       explorerMode = false;
                   }
                   return(moveDeadEnd(robot)); //moveDeadEnd returns the direction to move. This is returned to the main controlRobot subroutine
               case 2:
                   return(moveCorridor(robot));
               default: //Moving at crossroads (4 exits) and at junctions (3 exits) can be executed by the same code
                   doRecordJunction(robot); //As the robot has reached a junction, record the junction data in the Robot Data class
                   return(moveJunction(robot));
           }
       }
   
       private int backtrackControl(IRobot robot){
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           if(numExits > 2){ //Robot at junction or crossroad
               return(backtrackAtJunctionCrossroads(robot));
           }
           else{ //If there are less than or equal to 2 exits, we can just use the exploreControl to select the appropriate move for at a dead end / corridor.
               return(exploreControl(robot)); //This saves the need for an extra subroutine for backtracking at corridors and junctions.
           }
       }
   
       private int backtrackAtJunctionCrossroads(IRobot robot){ //Handles the backtracking if the robot is at a junction or at crossroads.
           int numPassageExits = calcNumExits(robot,IRobot.PASSAGE); //Calculate the number of passage exits.
   
           robotData.popFinalRouteStack(); //finalRouteStack popped as a new move will be chosen for this junction
           robotData.printStack();
   
           if (numPassageExits > 0){ //If there is an unexplored passage, switch back into explorer mode.
               explorerMode = true;
               atJunction = true; //If there is a passage record the heading that the robot moves for the final route stack
               return(exploreControl(robot)); //Call the explorer control function to determine the move, as explorer mode has been activated
           }
           else{ //Exit the junction the opposite way that the robot entered
               return(exitJunctionReverse(robot));
           }
       }
   
       private void recordFinalRouteHeading(IRobot robot, int direction){ //When at a junction, add the heading moved to the final route stack
           robotData.recordChosenHeading(convertRelativeDirectionToHeading(robot, direction)); //convert the direction to a heading and record
           atJunction = false; //no longer at a junction
       }
   
       private int exitJunctionReverse(IRobot robot){ //Exit the junction the opposite way to which the robot was heading when it found the junction the first time.
           int headingEnteredJunction = robotData.searchJunction(); //Get the top element from the stack.
           robotData.printStack();
           int reverseOfHeading = calculateReverseOfHeading(headingEnteredJunction); //Calculate reverse of the heading
           int directionToMove = convertHeadingToRelativeDirection(robot, reverseOfHeading); //Convert the reverse of the heading to a relative direction, as my controlRobot uses relative directions to move.
           return directionToMove;
       }
   
       private int calculateReverseOfHeading(int heading){
           return (IRobot.NORTH + (heading + 2) % 4); //If travelling south the robot would have arrived from north, so add 2 to the heading arrived from
           //Moduli 4 as there are 4 directions. Otherwise e.g. IRobot.WEST + 2 would not result in a valid direction.
       }
   
       private int convertHeadingToRelativeDirection(IRobot robot, int heading){
           int difference = heading - robot.getHeading(); //get the difference between current heading and the heading to look
           int relativeDirection = IRobot.AHEAD + (IRobot.AHEAD + difference) % 4;
           //Calculate the relative direction by adding the difference to IRobot.AHEAD. Modulo 4 as there are 4 directions.
           return relativeDirection;
       }
   
       private int convertRelativeDirectionToHeading(IRobot robot, int direction){
           int difference = direction - IRobot.AHEAD; //get the difference between current heading and the heading to look
           int heading = IRobot.NORTH + (robot.getHeading() + difference) % 4;
           //Calculate the relative direction by adding the difference to IRobot.AHEAD. Modulo 4 as there are 4 directions.
           return heading;
       }
   
       private void doRecordJunction(IRobot robot){
           atJunction = true; //As at a junction, record the heading chosen
   
           if(calcNumExits(robot,IRobot.BEENBEFORE) <=1){ //If been before exit <= 1, the junction is unexplored
               robotData.recordJunction(robot); //Only record junction if the junction is unexplored
           }
       }
   
       private int nonWallExits(IRobot robot){ //returns the number of non-WALL squares adjacent to the square currently occupied.
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterates through each relative direction
               if(robot.look(direction) != IRobot.WALL){ //For each direction, check if an exit lies ahead
                   numExits++; //If an exit lies ahead, increment the number of exits
               }
           }
           return numExits;
       }
   
       private int calcNumExits(IRobot robot, int exitType){ //Pass in an exit type and it calculates how many exits of that type are around the robot
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) == exitType){ //For each direction, check if there is a path matching exitType
                   numExits++; //Increment if there is a matching path.
               }
           }
           return numExits;
       }
   
       private int moveDeadEnd(IRobot robot){
           //Check each direction for the exit. Cannot just reverse direction, as robot could be facing any direction at the start
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collision
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveDeadEnd");
           /*As there should always be an exit that the robot can travel down at a dead end,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveCorridor(IRobot robot){
           //Check all directions apart from behind. Robot should not reverse direction when travelling along a corridor
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               if(direction != IRobot.BEHIND && robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collisin
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveCorridor");
           /*As there should always be >= 1 exit that the robot can travel down in a corridor,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveJunction(IRobot robot){
           ArrayList<Integer> nonWallExitsList = new ArrayList<Integer>();
           ArrayList<Integer> passagesList = new ArrayList<Integer>();
           //List of the passages that the robot has not yet been explored
   
           int pathType; //e.g. IRobot.BEENBEFORE or IRobot.PASSAGE
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               pathType = robot.look(direction); //Get the type of path at the current direction.
   
               if(pathType == IRobot.PASSAGE){ //If the path is a passage add it to passages list
                   passagesList.add(direction);
               }
               else if(pathType != IRobot.WALL){ //If the path is an exit add it to the nonWallExitsList
                   nonWallExitsList.add(direction);
               }
           }
           if(passagesList.size()>0){ //If there is a passage exit:
               return(chooseRandomExit(passagesList)); //Choose a random exit out of all the passages and return that direction
           }
           else{ //If there are no unexplored passages, pick a random exit from all the nonWallExits.
               return(chooseRandomExit(nonWallExitsList));
           }
       }
   
       private int chooseRandomExit(ArrayList<Integer>exitList){
           //Takes in an array and returns a random element in that array.
           Random rand = new Random();
           return(exitList.get(rand.nextInt(exitList.size()))); //Chooses a random index from 0 to the (length of the array - 1)
       }
   
       public void reset() {
           robotData.resetJunctionStack();
           explorerMode = true; //Reset explorerMode so that the robot will be in explore mode next run.
           pollRun = 0; //Reset the number of polls this run.
           retraceIndex = 0;
           atJunction = false;
       }
   
       public void resetFinalRoute(){ //Clears the final route stack and resets the retracing variables
           retrace = false;
           retraceIndex = 0;
           robotData.resetFinalRouteStack();
       }
   }
   
   class RobotData{
       private HashMap<Integer, String> hashMapHeadings; //Used to convert headings to strings. IRobot.SOUTH -> 'SOUTH'
       Stack junctionStack; //Stack which records the most recently encountered junctions at the top.
       Stack finalRouteStack;
       //When arriving at a previously unencountered junction, it is pushed to the top of the stack.
       //Once a junction has been 'backtracked through', it is popped from the stack.
       //junctionStack - heading the robot arrived at the junction. finalRouteStack - heading robot left the junction
       //They are separate stacks as they both have to be cleared at different points in the program's execution.
   
       RobotData(){ //Class Constructor
           this.junctionStack = new Stack();
           this.finalRouteStack = new Stack();
           createHeadingsHashMap(); //Create the hashMap for headings.
       }
   
       public void recordJunction(IRobot robot){
           this.junctionStack.push((short)robot.getHeading()); //push the robot's current heading to the stack.
           //Heading is cast to Short primitive type to save space, as headings are only in the range 1000-1003
       }
   
       public void recordChosenHeading(int heading){
           this.finalRouteStack.push((short)heading); //Push the heading to the finalRouteStack
           printStack();
       }
   
       public void resetJunctionStack(){
           this.junctionStack.clearStack(); //Remove all elements from the stack so that a new run can be started.
       }
   
       public void resetFinalRouteStack(){
           this.finalRouteStack.clearStack(); //Remove all elements from the stack so that a new run can be started.
       }
   
       public int searchJunction(){ //Returns heading of robot when the junction was first encountered
           return(junctionStack.pop()); //All that is needed is to pop the item at the top of the stack, which will contain the most recently encountered junction
       }
   
       public int popFinalRouteStack(){
           return(finalRouteStack.pop());
       }
   
   
       private void createHeadingsHashMap(){
           hashMapHeadings = new HashMap<Integer, String>(){ //Creates a hashmap with integers as the key (e.g. IRobot.NORTH) and string as the value (e.g. 'NORTH')
               {
                   put(IRobot.NORTH, "NORTH");
                   put(IRobot.EAST, "EAST");
                   put(IRobot.SOUTH, "SOUTH");
                   put(IRobot.WEST, "WEST");
               }
           };
       }
   
       public void printStack(){ //Print the final route stack
           finalRouteStack.printStack(hashMapHeadings);
       }
   
       public int retraceGetNextHeading(int index){
           return (finalRouteStack.getElemFromStack(index)); //Gets the heading from the final route stack at the specified index.
       }
   }
   
   class Stack{ //stack that contains integer values
       private ArrayList<Short> stackList;
       private int stackSize = 0; //Represents the number of elments in the stack.
   
       Stack(){ //Class constructor creates a new stackList.
           stackList = new ArrayList<Short>();
       }
   
       public int pop(){ //pop top element from stack and returns that element
           stackSize--; //decrement stackSize
           return(stackList.remove(stackSize)); //remove the last element in the arrayList. Note: as stackSize has been decremented, remove at index stackSize, not stackSize - 1.
       }
   
       public void push(short heading){ //push a given heading ontop of the stack
           stackList.add(heading);
           stackSize++; //Increment stack size as a new element has been added to the arrayList
       }
   
       public void clearStack(){
           stackSize = 0; //Reset stack size to 0 as there are now no items in the arrayList.
           stackList.clear();
       }
   
       public int getElemFromStack(int index){ //Gets element from stack at specified index.
           return (stackList.get(index));
       }
   
       public void printStack(HashMap<Integer, String> hashMapHeadings){
           System.out.print("Route: ");
           for (int i = 0; i<=stackSize -1 ;i++ ) { //Loops through elach element in the stack
               System.out.print(hashMapHeadings.get((int)stackList.get(i)) + ", ");
               //Gets the corresponding string for the heading from the hash map and prints it.
           }
           System.out.println();
       }
   
   }
   
   class EventClient implements IEventClient{
       private GrandFinale controller; //Holds the controller so that methods can be called.
       private final Set<String> disallowedGenerators = Set.of(new LoopyGenerator().getClass().getName(), new HillGenerator().getClass().getName(), new BlankGenerator().getClass().getName());
       //Set of maze generators that contain loops. If the user selects one of these generators, my program will output an appropriate warning message. (Cannot detect user added generators that contain loops)
   
       public EventClient(GrandFinale myController){
           this.controller = myController; //Set the controller instance when the EventClient class is instantiated.
       }
   
       @Override
       public void notify(IEvent e){ //Overrides the IEventCient notify function so that my controller can get event messages.
           int msg = e.getMessage(); //Get the event message (event code)
   
           if(msg == 110){ //Event code for when a new generator is loaded in
               newGeneratorLoaded(e, disallowedGenerators);
           }
           else if(msg == 107 || msg == 115){ //If the event code is 107(New Maze) or 115(Load Maze), reset variables and stacks.
               newMazeLoaded();
           }
       }
   
       private void newMazeLoaded(){ //When the user presses the New Maze or Load Maze button, all variables should be reset.
           this.controller.resetFinalRoute(); //If a new maze is created clear the finalRouteStack
           this.controller.reset(); //Also clear junctionStack and reset all variables
           System.out.println("New maze loaded. Resetting...");
       }
   
       private void newGeneratorLoaded(IEvent e, Set<String> disallowedGenerators){
           IMazeGenerator mazeGen = (IMazeGenerator)e.getData(); //The data sent in the event is the new maze generator that will be used.
           if(disallowedGenerators.contains(mazeGen.getClass().getName())){ //If the new generator creates mazes with loops, the backtracking will not work.
               System.out.println("Warning: this controller does not find the quickest route in mazes with loops!");
           }
       }
   }
