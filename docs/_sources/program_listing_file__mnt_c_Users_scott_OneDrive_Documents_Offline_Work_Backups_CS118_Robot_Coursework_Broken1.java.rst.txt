
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Broken1.java:

Program Listing for File Broken1.java
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Broken1.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Broken1.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   /*
    * File:    Broken  .java
    * Created: 7 September 2001
    * Author:  Stephen Jarvis
    */
   
   import uk.ac.warwick.dcs.maze.logic.IRobot;
   import java.util.HashMap;
   import java.util.Random;
   import java.util.ArrayList;
   
   public class Broken
   {
   
     public void controlRobot(IRobot robot) {
   
       int direction;
       int randno;
       int heading;
   
       heading = headingController(robot);
       direction = ReturnDirectionFromHeading(robot, heading);
   
       robot.face(direction);  /* Face the direction */
   
     }
   
     public int headingController(IRobot robot){
         /*Returns a heading that moves robot towards target
   
         Adds the target headings to a list. If there is a wall blocking that heading, it is removed
         from the possible headings. If there are multiple possible heading that lead the robot
         towards its target, a random one of the two are chosen. If there are no headings that lead the
         robot towards the target as walls are blocking them, a random heading is chosen through a separate
         function.
         */
   
         byte targetNorth = isTargetNorth(robot);
         byte targetEast = isTargetEast(robot);
         int headingToMove;
   
         ArrayList<Integer> possibleHeadings = new ArrayList<Integer>();
   
         if(targetNorth == 1){possibleHeadings.add(IRobot.NORTH);}
         else if(targetNorth == -1){possibleHeadings.add(IRobot.SOUTH);}
   
         if(targetEast == 1){possibleHeadings.add(IRobot.EAST);}
         else if(targetEast == -1){possibleHeadings.add(IRobot.WEST);}
   
         for (int i = 0; i < possibleHeadings.size(); i++) {
             //Remove any headings that have a wall blocking the path
             if (lookHeading(robot, possibleHeadings.get(i)) == IRobot.WALL){
                 possibleHeadings.remove(i); //remove heading at current index if a wall is blocking
                 i--; //Decrement i as an element of the arraylist was removed
             }
         }
   
         if (possibleHeadings.size() > 1){
             //Choose a random heading out of all the possible headings
             Random rand = new Random();
             headingToMove = possibleHeadings.get(rand.nextInt(possibleHeadings.size()));
         }
         else if(possibleHeadings.size() == 1){
             //If there is only one heading choose that one
             headingToMove = possibleHeadings.get(0);
         }else{
             //pick random heading
             headingToMove = ChooseRandomMove(robot);
         }
   
         return headingToMove;
         //Returns heading to main subroutine
   
     }
   
     public int ChooseRandomMove(IRobot robot){
         //Returns a random heading that does not cause a collision
         int randomheading;
         double randno;
   
         do{
             randno = Math.random();
   
             if(randno <0.25){ //Direction chosen based on random number
                 randomheading = IRobot.NORTH;
             }
             else if(randno >=0.25 && randno <0.5){
                 randomheading = IRobot.SOUTH;
             }
             else if(randno >=0.5 && randno <0.75){
                 randomheading = IRobot.EAST;
             }
             else{
                 randomheading = IRobot.WEST;
             }
         } while(lookHeading(robot, randomheading) == IRobot.WALL);
         //Choose a heading again if the robot is facing a wall
   
         return randomheading;
     }
   
     public byte isTargetNorth(IRobot robot){
        if(robot.getTargetLocation().y <  robot.getLocation().y){ //IF TARGET IS NORTH
            return 1;
        }else if(robot.getTargetLocation().y >  robot.getLocation().y){ //IF TARGET IS SOUTH
            return -1;
        }else{
            return 0;
        }
     }
   
     public byte isTargetEast(IRobot robot){
        if(robot.getTargetLocation().x >  robot.getLocation().x){ //IF TARGET IS EAST
            return 1;
        }else if(robot.getTargetLocation().x <  robot.getLocation().x){ //IF TARGET IS WEST
            return -1;
        }else{
            return 0;
        }
     }
   
   public int ReturnDirectionFromHeading(IRobot robot, int headingToLook){
       //Converts from heading to the direction relative to the robot.
       //E.g. If robot facing EAST and want to move NORTH, this function will return IRobot.LEFT
   
       int difference = headingToLook - robot.getHeading(); //get the difference between current heading and the heading to look
       int directionToLook = IRobot.AHEAD + difference; //calculate the direction to look by adding the difference to straight ahead
       if(directionToLook < IRobot.AHEAD){directionToLook += 4;}
       //If the difference is negative, add 4. e.g. if the heading to look was 1 and the robot heading was 3
       //this would result in a direction less than IRobot.AHEAD (<2000), which is invalid
   
       return directionToLook;
   }
   
     public int lookHeading (IRobot robot, int headingToLook){
   
         int directionToLook = ReturnDirectionFromHeading(robot, headingToLook);
         //Get the direction relative to the robot, from the heading
   
         return(robot.look(directionToLook));
         //Look in the direciton of the desired heading
   
     }
   
   
   
   }
