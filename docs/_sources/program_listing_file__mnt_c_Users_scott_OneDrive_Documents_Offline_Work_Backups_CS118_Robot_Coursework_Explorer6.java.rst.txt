
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer6.java:

Program Listing for File Explorer6.java
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer6.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Explorer6.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   import uk.ac.warwick.dcs.maze.logic.IRobot;
   import java.util.ArrayList;
   import java.util.Random;
   import java.util.HashMap;
   
   public class Explorer{
   
       private int pollRun = 0;
       private RobotData robotData;
       private boolean explorerMode;
   
       public void controlRobot(IRobot robot){
           int directionToMove;
   
           initRobotData(robot); //Creates the RobotData class if this is the first run
   
           if (explorerMode == true){ //If explore mode on, call the exploreControl subroutine.
               directionToMove = exploreControl(robot);
           }
           else{
               directionToMove = backtrackControl(robot);
           }
   
           robot.face(directionToMove);
       }
   
       private int exploreControl(IRobot robot){ //Returns the direction the robot should move in based on how many exits surround the robot
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           switch (numExits){
               case 1:
                   if(pollRun > 1){ //Only set to backtrack if not at the start. If started at a dead end, still should be in explore mode.
                       explorerMode = false;
                       System.out.println("Dead end reached. Entering Backtracking Mode");
                   }
                   return(moveDeadEnd(robot)); //moveDeadEnd returns the direction to move. This is returned to the main controlRobot subroutine
               case 2:
                   return(moveCorridor(robot));
               default: //Moving at crossroads (4 exits) and at junctions (3 exits) can be executed by the same code
                   DoRecordJunction(robot); //As the robot has reached a junction, record the junction data in the Robot Data class
                   return(moveJunction(robot));
           }
       }
   
       private int backtrackControl(IRobot robot){
           int numExits = nonWallExits(robot); //Calculate number of exits
           int numPassageExits;
   
           if(numExits > 2){ //Robot at junction or crossroad
               System.out.print("Backtracking at a junc/crossroads: ");
               return(backtrackAtJunctionCrossroads(robot));
           }
           else{ //If there are less than or equal to 2 exits, we can just use the exploreControl to select the appropriate move for at a dead end / corridor.
               System.out.println("Backtracking at a corridor/dead end. Using exploreControl to decide the move.");
               return(exploreControl(robot));
           }
       }
   
       private int backtrackAtJunctionCrossroads(IRobot robot){
           int numPassageExits = calcNumExits(robot,IRobot.PASSAGE); //Calculate the number of passage exits.
   
           if (numPassageExits > 0){ //If there is an unexplored passage, switch back into explorer mode.
               System.out.println("Found a passage at the junc/crossroads, switching back to explorer mode.");
               explorerMode = true;
               return(exploreControl(robot)); //Call the explorer control function to determine the move, as explorer mode has been activated
           }
           else{ //Exit the junction the opposite way that the robot entered
               System.out.println("No passages found, exiting junction the opposite way that I first encountered it.");
               return(ExitJunctionReverse(robot));
           }
       }
   
       private int ExitJunctionReverse(IRobot robot){ //Exit the junction the opposite way to which the robot was heading when it found the junction the first time.
           int headingEnteredJunction = robotData.searchJunction(robot.getLocation().x,robot.getLocation().y); //Search each junction recorder for data about the junction
           int reverseOfHeading = CalculateReverseOfHeading(headingEnteredJunction); //Calculate reverse of the heading
           int directionToMove = ConvertHeadingToRelativeDirection(robot, reverseOfHeading); //Convert the reverse of the heading to a relative direction.
           return directionToMove;
       }
   
       private int CalculateReverseOfHeading(int heading){
           //If travelling south the robot would have arrived from north, so add 2 to the heading arrived from
           //Then moduli 4 as there are 4 directions. Otherwise e.g. IRobot.WEST + 2 would not result in a valid direction.
           return (IRobot.NORTH + (heading + 2) % 4);
       }
   
       private int ConvertHeadingToRelativeDirection(IRobot robot, int heading){
           int difference = heading - robot.getHeading(); //get the difference between current heading and the heading to look
           int relativeDirection = IRobot.AHEAD + (IRobot.AHEAD + difference) % 4;
           //Calculate the relative direction by adding the difference to IRobot.AHEAD. Modulo 4 as there are 4 directions.
           return relativeDirection;
       }
   
       private void initRobotData(IRobot robot){
           if((robot.getRuns() == 0) && pollRun == 0){ //Only create a robot data class if this is the first run and the first time controlRobot has been polled this run
               robotData = new RobotData();
               explorerMode = true; //Robot starts in explorer mode
               System.out.println("Creating the RobotData class");
           }
           pollRun++; //Increment the pollRun variable to avoid a new RobotData class being created next poll.
       }
   
       private void DoRecordJunction(IRobot robot){
           if(calcNumExits(robot,IRobot.BEENBEFORE) <=1){ //If been before exit <= 1 , the junction is unexplored
               robotData.RecordJunction(robot); //Only record junction if the junction is unexplored
           }
       }
   
       private int nonWallExits(IRobot robot){ //returns the number of non-WALL squares adjacent to the square currently occupied.
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterates through each relative direction
               if(robot.look(direction) != IRobot.WALL){ //For each direction, check if an exit lies ahead
                   numExits++; //If an exit lies ahead, increment the number of exits
               }
           }
           return numExits;
       }
   
       private int calcNumExits(IRobot robot, int exitType){ //Pass in an exit type and it calculates how many exits of that type are around the robot
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) == exitType){ //For each direction, check if there is a path matching exitType
                   numExits++; //Increment if there is a matching path.
               }
           }
           return numExits;
       }
   
       private int moveDeadEnd(IRobot robot){
           //Check each direction for the exit. Cannot just reverse direction, as robot could be facing any direction at the start
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collision
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveDeadEnd");
           /*As there should always be an exit that the robot can travel down at a dead end,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveCorridor(IRobot robot){
           //Check all directions apart from behind. Robot should not reverse direction when travelling along a corridor
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               if(direction != IRobot.BEHIND && robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collisin
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveCorridor");
           /*As there should always be >= 1 exit that the robot can travel down in a corridor,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveJunction(IRobot robot){
           ArrayList<Integer> nonWallExitsList = new ArrayList<Integer>();
           ArrayList<Integer> passagesList = new ArrayList<Integer>();
           //List of the passages that the robot has not yet been explored
   
           int pathType; //e.g. IRobot.BEENBEFORE or IRobot.PASSAGE
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               pathType = robot.look(direction); //Get the type of path at the current direction.
   
               if(pathType == IRobot.PASSAGE){ //If the path is a passage add it to passages list
                   passagesList.add(direction);
               }
               else if(pathType != IRobot.WALL){ //If the path is an exit add it to the nonWallExitsList
                   nonWallExitsList.add(direction);
               }
           }
           if(passagesList.size()>0){ //If there is a passage exit:
               return(chooseRandomExit(passagesList)); //Choose a random exit out of all the passages and return that direction
           }
           else{ //If there are no unexplored passages, pick a random exit from all the nonWallExits.
               return(chooseRandomExit(nonWallExitsList));
           }
       }
   
       private int chooseRandomExit(ArrayList<Integer>exitList){
           //Takes in an array and returns a random element in that array.
           Random rand = new Random();
           return(exitList.get(rand.nextInt(exitList.size()))); //Chooses a random index from 0 to the (length of the array - 1)
       }
   
       public void reset() {
           robotData.resetJunctionCounter();
           explorerMode = true; //Reset explorerMode so that the robot will be in explore mode next run.
           pollRun = 0; //Reset the number of polls this run.
       }
   }
   
   class RobotData{
       private HashMap<Integer, String> hashMapHeadings;
       private int junctionCounter = 0; //Represents the last index of the erray
       ArrayList<JunctionRecorder> arrayOfJunctionRecorders;
       /*I chose an arrayList to hold the junctionRecorders, as new junctionRecoders are being added with every junction that is found.
       If an array with 10,000 max junctions were used (as in the guide), there would typically be a large amount of wasted space in the array,
       as it is very unlikely that the number of junctions encountered would reach near 10,000. */
   
       RobotData(){ //Class Constructor
           this.arrayOfJunctionRecorders = new ArrayList<JunctionRecorder>();
           CreateHashMap(); //Create the hashMap for headings.
       }
   
       public void RecordJunction(IRobot robot){
           this.arrayOfJunctionRecorders.add(new JunctionRecorder(robot.getLocation().x,robot.getLocation().y,robot.getHeading()));
           //Add a new junctionRecorder to the ArrayList, passing in the coordinates and heading of the robot as the properties of the junction.
           printJunction(junctionCounter); //print the details of the newly encountered junction
   
           junctionCounter++; //Increment the junction counter for when another junction is encountered.
       }
   
       public void resetJunctionCounter(){
           junctionCounter = 0; //Reset the index of the arraylist to 0
           arrayOfJunctionRecorders.clear(); //Remove all items from the collection.
           System.out.println("Resetting junction counter");
       }
   
       private void printJunction(int indexOfJunctionRecorder){
           JunctionRecorder CurrentJunctionRecorder = arrayOfJunctionRecorders.get(indexOfJunctionRecorder);
           //Get the junction recorder specifies by the indexOfJunctionRecorder paramter
   
           int CurrentJuncX = CurrentJunctionRecorder.getJuncX();
           int CurrentJuncY = CurrentJunctionRecorder.getJuncY();
           String CurrentHeadingArrivedFrom = hashMapHeadings.get(CurrentJunctionRecorder.getHeadingArrived());
           //Uses the hashmap to converting headings to strings e.g. IRobot.NORTH --> 'NORTH'
   
           System.out.printf("Junction %d (x=%d,y=%d) heading %s \n", indexOfJunctionRecorder,CurrentJuncX,CurrentJuncY,CurrentHeadingArrivedFrom);
       }
   
       private void CreateHashMap(){
           hashMapHeadings = new HashMap<Integer, String>(){
               {
                   put(IRobot.NORTH, "NORTH");
                   put(IRobot.EAST, "EAST");
                   put(IRobot.SOUTH, "SOUTH");
                   put(IRobot.WEST, "WEST");
               }
           };
       }
   
       public int searchJunction(int juncX, int juncY){ //Returns heading of robot when the junction was first encountered
           //Search through array of junction recorders, starting at the most recently encountered junctions.
           //The junction is more likely to be at the end of the list so start there and iterate back through the array
   
           JunctionRecorder juncToCompare;
   
           for (int i = this.arrayOfJunctionRecorders.size()-1; i >= 0; i-- ) {
               juncToCompare = arrayOfJunctionRecorders.get(i);
               if (juncToCompare.getJuncX() == juncX && juncToCompare.getJuncY() == juncY)  {
                   return juncToCompare.getHeadingArrived();
               }
           }
   
           throw new AssertionError("unreachable code reached in searchJunction (no junction found)");
           /*If in backtracking mode and the robot reaches a junction, it should be in the list of encountered junctions.
           So if no junction can be found in the arrayList, even though the robot should have visited it before, a serious error has occured*/
   
       }
   }
   
   class JunctionRecorder{
       private int juncX;
       private int juncY;
       private int headingArrived;
   
       JunctionRecorder(int x, int y, int headingArrived){
           this.setJunctionLocation(x, y);
           this.setHeadingArrived(headingArrived);
       }
   
       private void setJunctionLocation(int x, int y){
           this.juncX = x;
           this.juncY = y;
       }
   
       private void setHeadingArrived(int heading){
           this.headingArrived = heading;
       }
   
       public int getJuncX(){
           return juncX;
       }
   
       public int getJuncY(){
           return juncY;
       }
   
       public int getHeadingArrived(){
           return headingArrived;
       }
   }
