
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer3.java:

Program Listing for File Explorer3.java
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer3.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Explorer3.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   import uk.ac.warwick.dcs.maze.logic.IRobot;
   import java.util.ArrayList;
   import java.util.Random;
   
   public class Explorer{
   
       public void controlRobot(IRobot robot){
   
           int direction;
           int exits = nonWallExits(robot);
   
           switch (exits){
               case 1:
                   direction = moveDeadEnd(robot);
                   break;
               case 2:
                   direction = moveCorridor(robot);
                   break;
               case 3:
                   direction = moveJunction(robot);
                   break;
               default:
                   direction = moveCrossroads(robot);
           }
   
           robot.face(direction);
       }
   
       private int nonWallExits(IRobot robot){
           //returns the number of non-WALL squares adjacent to the square currently occupied.
   
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               if(robot.look(direction) != IRobot.WALL){
                   numExits++;
               }
           }
   
           return numExits;
       }
   
       private int moveDeadEnd(IRobot robot){
           //At the start the dead end will be behind the IRobot
   
           if (robot.look(IRobot.AHEAD)==IRobot.WALL){
               System.out.println("daed");
               return (IRobot.BEHIND);
   
           }
           else{
               System.out.println("starrdaf");
               return(IRobot.AHEAD);
   
           }
       }
   
       private int moveCorridor(IRobot robot){
           //Check all directions apart from behind. Robot should not reverse direction
           for (int direction = IRobot.LEFT; direction <= IRobot.RIGHT; direction++) {
               if(robot.look(direction) != IRobot.WALL){
                   return direction;
               }
           }
   
       }
   
       private int moveJunction(IRobot robot){
           ArrayList<Integer> nonWallExitsList = new ArrayList<Integer>();
           int pathType;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               pathType = robot.look(direction);
   
               if(pathType == IRobot.PASSAGE){
                   return direction;
               }
               if(pathType != IRobot.WALL){
                   nonWallExitsList.add(direction);
               }
           }
   
           Random rand = new Random();
           directionToMove = nonWallExitsList.get(rand.nextInt(nonWallExitsList.size()));
       }
   
       private int moveCrossroads(IRobot robot){
           return(2000);
       }
   }
