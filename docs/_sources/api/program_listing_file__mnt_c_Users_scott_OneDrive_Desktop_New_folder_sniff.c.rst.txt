
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Desktop_New_folder_sniff.c:

Program Listing for File sniff.c
================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Desktop_New_folder_sniff.c>` (``/mnt/c/Users/scott/OneDrive/Desktop/New folder/sniff.c``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #include "sniff.h"
   
   #include <stdio.h>
   #include <stdlib.h>
   #include <netinet/if_ether.h>
   
   #include "dispatch.h"
   #include "analysis.h"
   
   #include <signal.h>
   #include <stdlib.h>
   
   pcap_t *pcap_handle; //Global var so dispatch.c can access - see sniff.h
   
   void packet_handler(u_char *args, const struct pcap_pkthdr * header, const u_char *packet){
     int verbose = (int) *args; //verbose is the 
     if (packet == NULL) {
         if (verbose) {
           printf("No packet received. %s\n", pcap_geterr(pcap_handle));
         }
     } 
     else {
       // If verbose is set to 1, dump raw packet to terminal
       if (verbose) { //ONLY CALL DUMP IF -v FLAG SET == TRUE
         dump(packet, header->len);
       }
       // Dispatch packet for processing
       dispatch(header, packet, verbose); //call dispatch to give job to a thread
     }
   
     return;
   }
   
   // Application main sniffing loop
   void sniff(char *interface, int verbose) {
     
     char errbuf[PCAP_ERRBUF_SIZE];
     initThreadPool(); //Starting sniffing session so create the threadpool
     initAnalysis();
   
     // Open the specified network interface for packet capture. pcap_open_live() returns the handle to be used for the packet
     // capturing session. check the man page of pcap_open_live()
     pcap_handle = pcap_open_live(interface, 4096, 1, 1000, errbuf); //Opens capture session
     if (pcap_handle == NULL) { //If managed to establish capturing session
       fprintf(stderr, "Unable to open interface %s\n", errbuf);
       exit(EXIT_FAILURE);
     } else {
       printf("SUCCESS! Opened %s for capture\n", interface);
     }
     
     free(interface); //Free the interface variable allocated by strdup() in main
     
     // Capture packet one packet everytime the loop runs using pcap_next(). This is inefficient.
     // A more efficient way to capture packets is to use use pcap_loop() instead of pcap_next().
   
     pcap_loop(pcap_handle, 0, packet_handler, (u_char *)&verbose);
   }
   
   // Utility/Debugging method for dumping raw packet data. Parses packet data
   void dump(const unsigned char *data, int length) { //*data is a pointer to the start of the packet
     unsigned int i;
     static unsigned long pcount = 0;
     // Decode Packet Header
     struct ether_header *eth_header = (struct ether_header *) data; //Convert packet into an ethernet header struct
     printf("\n\n === PACKET %ld HEADER ===", pcount);
     printf("\nSource MAC: ");
     for (i = 0; i < 6; ++i) {
       printf("%02x", eth_header->ether_shost[i]);
       if (i < 5) {
         printf(":");
       }
     }
     printf("\nDestination MAC: ");
     for (i = 0; i < 6; ++i) {
       printf("%02x", eth_header->ether_dhost[i]);
       if (i < 5) {
         printf(":");
       }
     }
     printf("\nType: %hu\n", eth_header->ether_type);
     printf(" === PACKET %ld DATA == \n", pcount);
     // Decode Packet Data (Skipping over the header)
     int data_bytes = length - ETH_HLEN;
     const unsigned char *payload = data + ETH_HLEN;
     const static int output_sz = 20; // Output this many bytes at a time
     while (data_bytes > 0) {
       int output_bytes = data_bytes < output_sz ? data_bytes : output_sz;
       // Print data in raw hexadecimal form
       for (i = 0; i < output_sz; ++i) {
         if (i < output_bytes) {
           printf("%02x ", payload[i]);
         } else {
           printf ("   "); // Maintain padding for partial lines
         }
       }
       printf ("| ");
       // Print data in ascii form
       for (i = 0; i < output_bytes; ++i) {
         char byte = payload[i];
         if (byte > 31 && byte < 127) {
           // Byte is in printable ascii range
           printf("%c", byte);
         } else {
           printf(".");
         }
       }
       printf("\n");
       payload += output_bytes;
       data_bytes -= output_bytes;
     }
     pcount++;
   }
