
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Desktop_New_folder_analysis.c:

Program Listing for File analysis.c
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Desktop_New_folder_analysis.c>` (``/mnt/c/Users/scott/OneDrive/Desktop/New folder/analysis.c``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #include "analysis.h"
   
   #include <pcap.h>
   #include <netinet/if_ether.h>
   #include <netinet/ip.h>
   #include <netinet/tcp.h>
   #include <arpa/inet.h>
   #include <stdlib.h>
   #include <string.h>
   #include <pthread.h>
   
   #define SIZE_ETHERNET 14
   
   unsigned long syn_packet_count = 0; //whenever syn = 1 seen increment count
   unsigned long syn_packet_unique_ip_count = 0; //if ip not already seen increment unique ip count
   unsigned long * ip_addresses; //Array of encountered ip addresses (initially empty)
   unsigned long arp_response_count=0;
   unsigned long blacklist_url_count=0;
   
   pthread_mutex_t syn_mutex = PTHREAD_MUTEX_INITIALIZER;
   pthread_mutex_t arp_mutex = PTHREAD_MUTEX_INITIALIZER;
   pthread_mutex_t blacklist_mutex = PTHREAD_MUTEX_INITIALIZER;
   
   
   void initAnalysis(){
     ip_addresses = calloc(1, sizeof(unsigned long)); //allocate memory for array of ip addresses
   }
   
   unsigned short get_ip_len(const unsigned char * data){
     data += SIZE_ETHERNET; //Get to start of ip header
     struct ip *ip_header = (struct ip *) data; 
     return (ip_header->ip_hl) * 4; //Times ip header length by 4 to get number of bytes
   }
   
   unsigned short get_tcp_len(const unsigned char * data, int len_ip){
     data += SIZE_ETHERNET + len_ip;
     struct tcphdr *tcp_header = (struct tcphdr *) data; 
     return (tcp_header->th_off) * 4;
   }
   
   unsigned short get_payload_len(const unsigned char * data, int len_ip, int len_tcp){
     data += SIZE_ETHERNET;
     struct ip *ip_header = (struct ip *) data; 
   
     //Size of payload is IP packet size - ip header length - tcp header length
     return (ntohs(ip_header->ip_len) - len_ip - len_tcp); 
   
   }
   
   //Check array of encountered ip addresses to check if ip addresses already seen
   //If seen for the first time, increment count and add it to the ip addresses array
   //(Hashmap could be used here to speed up checking the array, but scanning array 
   //will lead to O(n^2) total operations, so speedup would be negligible).
   void do_syn(const unsigned char * data, int len_ip){
     data += SIZE_ETHERNET;
     struct ip *ip_header = (struct ip *) data;
     data += len_ip;
     struct tcphdr *tcp_header = (struct tcphdr *) data; 
   
     if(!(tcp_header->th_flags & TH_SYN)){
       return; //If syn flag not active then not a SYN packet so return
     }
   
   
     unsigned long source_addr = ntohl(ip_header->ip_src.s_addr); //Get source IP address to compare against previously seen IPs. ntohl() as ip is of long type
     pthread_mutex_lock(&syn_mutex);//Changing / accessing shared variables so acquire mutex lock
     syn_packet_count++; 
   
     int i;
     int found = 0; //assume ip address is not in list
     for(i = 0; i < syn_packet_unique_ip_count; i++){
       if(ip_addresses[i] == source_addr){ //If ip addresses previously seen, found set to true
         found = 1;
         break; //No need to search rest of array
       }
     }
     
     if(!found){ //If not found in ip array -> unique. 
       syn_packet_unique_ip_count++; //Increment unique ip counter
       ip_addresses = realloc(ip_addresses, syn_packet_unique_ip_count * sizeof(unsigned long)); //dynamically grow array
       if(ip_addresses == NULL){
         printf("Could not reallocate memory\n");
       }
       ip_addresses[syn_packet_unique_ip_count-1] = source_addr; //add source_addr to array
     }
     pthread_mutex_unlock(&syn_mutex);
   }
   
   //Check if the packet is an ARP packet by looking at the ethernet heading
   //Check if the ARP packet is a reply (by looking at the ARP response code)
   void do_arp(const unsigned char * data){
     struct ether_header * eth_header = (struct ether_header *) data; 
   
     if(ntohs(eth_header->ether_type) != 0x0806){ //If type of packet is not ARP then disregard
       return; //(Requires ntohs() as ether_type is u_short, which is a multi-byte representation)
     }
   
     data+=SIZE_ETHERNET; //Add size of ethernet header to now look at the arp_header
   
     struct arphdr *arp_header = (struct arphdr *) data; //Cast to an arp header 
     if(ntohs(arp_header->ar_op) == 2){ //If the opcode is REPLY, then we have found an ARP reply
       pthread_mutex_lock(&arp_mutex); //Incrementing shared variable so acquire lock
       arp_response_count++; //Found ARP reply so increment the count
       pthread_mutex_unlock(&arp_mutex);
     }
   }
   
   void print_blacklist_violation(const unsigned char * data){
     char ip_str[16];
     data += SIZE_ETHERNET; //SIZE_ETHERNET=14 is the size of the ethernet header, so plus 14 to get to start of IP header
     struct ip *ip_header = (struct ip *) data; //Convert packet into an ethernet header struct
   
     printf("==============================\n");
     printf("Blacklisted URL violation detected\n");
   
     printf("Source IP address: ");
     inet_ntop(AF_INET, &(ip_header->ip_src), ip_str, sizeof(ip_str));
     printf("%s \n", ip_str);
     //Converts the binary ip address to a string. AF_INET signifies IPv4
     printf("Destination IP address: ");
     inet_ntop(AF_INET, &(ip_header->ip_dst), ip_str, sizeof(ip_str));
     printf("%s\n", ip_str);
     printf("==============================\n");
   }
   
   //First check if incoming on port 80
   //Then check the http payload and compare requested URL to blacklisted URLs
   void do_blacklist(const unsigned char * data, int len_ip, int len_tcp, int len_payload){
     const unsigned char * original_data = data; //keep pointer to start of packet for printing the blacklist violation
   
     data += SIZE_ETHERNET + len_ip;
     struct tcphdr *tcp_header = (struct tcphdr *) data; 
   
     if(ntohs(tcp_header->th_dport) != 80 || len_payload == 0){ 
       return; //If not on port 80 or contains no payload then it cannot be a http request
     }
     data+=len_tcp; //Now look at TCP payload, which will be a http request
     char * http_request_string = malloc((len_payload+1) * sizeof(char));
   
     //Size of the http request will be the size of the TCP payload.
     //Copy the data into a temporary string so it can be checked for blacklists
     //Must be copied as need to add terminating character onto the end
     strncpy(http_request_string,(const char *)data,len_payload);
     http_request_string[len_payload] = '\0'; //Ensure string has terminating char
   
     //Check if GET request and if either of the two blacklisted URLs in request
     //strstr checks if second string present in first string
     if(strstr(http_request_string, "GET") && (strstr(http_request_string, "bbc.com") || strstr(http_request_string, "google.co.uk"))){
       pthread_mutex_lock(&blacklist_mutex);
       blacklist_url_count++; //Increment count
       pthread_mutex_unlock(&blacklist_mutex);
       print_blacklist_violation(original_data); //Print blacklist violation on the fly
     }
     
     free(http_request_string); //Free the temporary string
   }
   
   void analyse(const struct pcap_pkthdr *header,
                const unsigned char *packet,
                int verbose) {
     
     //Calcualte the length of headers and the size of the payload
     unsigned short len_ip = get_ip_len(packet);
     unsigned short len_tcp = get_tcp_len(packet, len_ip);
     unsigned short len_payload = get_payload_len(packet, len_ip, len_tcp);
   
     do_syn(packet, len_ip); 
     do_arp(packet);
     do_blacklist(packet, len_ip, len_tcp, len_payload);
   }
