
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_2_-_Copy_Ex1.java:

Program Listing for File Ex1.java
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_2_-_Copy_Ex1.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Complete Exercises/2 - Copy/Ex1.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   /*Ex1 Preamble: For the passageExits and beenBeforeExits methods, I decided it would be more efficient to combine them into one subroutine,
   otherwise there would be a large amount of repeating code. I created a new subroutine calcNumExits, that allows an exitType to be passed in,
   and it returned the number of exits of the specified type. As nonWallExits is slightly different – it considers the exits that do NOT have a wall in front -
   I decided to leave this in its own subroutine.
   
   The moveDeadEnd and moveCorridor methods were quite simple. For both methods I simply iterated through each relative direction to find the valid non-wall
   exit for the robot to take. The only difference was that moveCorridor does not consider IRobot.BEHIND, as that would just cause the robot to move back on itself.
   
   I noticed early on that the moveCrossroads method would be identical to moveJunction, so I combined them into the same subroutine,
   which would be called if the number of exits was 3 or 4. I started by creating two ArrayLists in moveJunction, to represent the passagesExits
   and nonWallExits the robot could take. While a normal array has a fixed length, an ArrayList’s length can alter, which suited this problem well,
   as the number of passages/nonWallExits vary depending on the junction that the robot is at.
   
   To create the RobotData class, I began creating a 2D array to represent the different junctions in 1 dimension, and then the junction’s properties in the second dimension.
   However, I quickly realised that an array of objects that each contained properties about a junction, would be a far superior implementation.
   I made a further enhancement by changing the array to an ArrayList, as new junctionRecoders are being added with every junction that is found.
   If an array with storage for up to 10,000 junctions was used (as in the guide), there would typically be a large amount of wasted space in the array.
   This is because it is extremely unlikely that the number of junctions encountered would reach anywhere near 10,000 each run.
   
   When the robot is backtracking and there is no passage exits at a junction, the robot exits the junction at the opposite direction to which it entered that junction.
   In RobotData, I created the searchJunction method which takes the X and Y coordinates of a junction, and iterates through the array of JunctionRecorders
   until it finds the corresponding JunctionRecorder. To improve efficiency, iteration begins at the end of the array, meaning that the most recently encountered
   junctions are checked first. To see why this is more efficient, if the robot goes down a path which takes it to a dead end, and backtracks to a junction,
   the corresponding junction will be stored as the last element of ArrayList. In this example, only one iteration needs to take place, instead of iterating
   through every junction that has been encountered.
   
   In the search junction method, instead of iterating through each junctionRecorder, one potential enhancement would be to create a hash table for each junctionRecorder,
   so that the desired junction could be easily looked up. The key could be calculated based on the X and Y of the junction,
   which could mean junctions are referenced in O(1) time, assuming there are a negligible number of collisions. However, I thought this was unnecessary,
   as the array of Junction Recorders is very small (<50 for most runs). With the relatively small size of the mazes, and my optimisation above,
   the required junction is found very quickly. Testing over 10 different mazes, I found an average of just 5.7 iterations to find the desired junction.
   
   Interestingly, in the backtracking subroutines, I call the exploreControl method twice. I realised that, instead of writing duplicate code in backtrackControl
   to determine what to do at a corridor or dead end, I could instead call exploreControl. This function call would return the direction to move,
   as calculated by moveCorridor or moveDeadEnd.
   
   The robot should always find the target in a Prim-generated maze (as long as the target is accesible), as my program will eventually search though the whole maze
   until the target is found. The only problem is when loops are introduced into the maze. I tested the program on the 'LoopyGenerator' and the robot got stuck in
   and infinte ciruit, following the same loop each time.
   
   We can determine the maximum number of steps that the robot can take for an arbitrary maze, by examing the number of crossroads, junctions, corridors and deadends.
   Beginning with dead ends, it is evident that the maximum number of times a robot would visit the dead end is 1. Then for a corridor square, the max is two (first time
   is travelling down the corridor, and second time is backtracking through). For junctions and crossroads, the maximum visits is 3 and 4 respectively. Therefore,
   the maximum number of times the robot visits a square is equal to the number of exits around that square. Consequentially, to calculate the worse case scenario for a given
   (Prim generated) maze, iterate through every square on the maze and sum up the total number of exits of all squares. This number will be the maximum number of steps that the
   robot will make. The max length of time to find the target can then be calculated by: max number of steps X time between steps.
   */
   
   import uk.ac.warwick.dcs.maze.logic.IRobot;
   import java.util.ArrayList;
   import java.util.Random;
   import java.util.HashMap;
   
   public class Ex1{
   
       private int pollRun = 0;
       private RobotData robotData;
       private boolean explorerMode;
   
       public void controlRobot(IRobot robot){
           int directionToMove;
   
           initRobotData(robot); //Creates the RobotData class if this is the first run
   
           if (explorerMode == true){ //If explore mode on, call the exploreControl subroutine.
               directionToMove = exploreControl(robot);
           }
           else{
               directionToMove = backtrackControl(robot);
           }
   
           robot.face(directionToMove);
       }
   
       private void initRobotData(IRobot robot){
           if((robot.getRuns() == 0) && pollRun == 0){ //Only create a robot data class if this is the first run and the first time controlRobot has been polled this run
               robotData = new RobotData();
               explorerMode = true; //Robot starts in explorer mode
               System.out.println("Creating the RobotData class");
           }
           pollRun++; //Increment the pollRun variable to avoid a new RobotData class being created next poll.
       }
   
       private int exploreControl(IRobot robot){ //Returns the direction the robot should move in based on how many exits surround the robot
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           switch (numExits){
               case 1:
                   if(pollRun > 1){ //Only set to backtrack if not at the start of maze. If started at a dead end, still should be in explore mode.
                       explorerMode = false;
                   }
                   return(moveDeadEnd(robot)); //moveDeadEnd returns the direction to move. This is returned to the main controlRobot subroutine
               case 2:
                   return(moveCorridor(robot));
               default: //Moving at crossroads (4 exits) and at junctions (3 exits) can be executed by the same code
                   doRecordJunction(robot); //As the robot has reached a junction, record the junction data in the Robot Data class
                   return(moveJunction(robot));
           }
       }
   
       private int backtrackControl(IRobot robot){
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           if(numExits > 2){ //Robot at junction or crossroad
               return(backtrackAtJunctionCrossroads(robot));
           }
           else{ //If there are less than or equal to 2 exits, we can just use the exploreControl to select the appropriate move for at a dead end / corridor.
               return(exploreControl(robot));
           }
       }
   
       private int backtrackAtJunctionCrossroads(IRobot robot){ //Handles the backtracking if the robot is at a junction or at crossroads.
           int numPassageExits = calcNumExits(robot,IRobot.PASSAGE); //Calculate the number of passage exits.
   
           if (numPassageExits > 0){ //If there is an unexplored passage, switch back into explorer mode.
               explorerMode = true;
               return(exploreControl(robot)); //Call the explorer control function to determine the move, as explorer mode has been activated
           }
           else{ //Exit the junction the opposite way that the robot entered
               return(exitJunctionReverse(robot));
           }
       }
   
       private int exitJunctionReverse(IRobot robot){ //Exit the junction the opposite way to which the robot was heading when it found the junction the first time.
           int headingEnteredJunction = robotData.searchJunction(robot.getLocation().x,robot.getLocation().y); //Search each junction recorder for data about the junction at the robot's current position.
           int reverseOfHeading = calculateReverseOfHeading(headingEnteredJunction); //Calculate reverse of the heading
           int directionToMove = convertHeadingToRelativeDirection(robot, reverseOfHeading); //Convert the reverse of the heading to a relative direction, as my controlRobot uses relative directions to move.
           return directionToMove;
       }
   
       private int calculateReverseOfHeading(int heading){
           return (IRobot.NORTH + (heading + 2) % 4); //If travelling south the robot would have arrived from north, so add 2 to the heading arrived from
           //Moduli 4 as there are 4 directions. Otherwise e.g. IRobot.WEST + 2 would not result in a valid direction.
       }
   
       private int convertHeadingToRelativeDirection(IRobot robot, int heading){
           int difference = heading - robot.getHeading(); //get the difference between current heading and the heading to look
           int relativeDirection = IRobot.AHEAD + (IRobot.AHEAD + difference) % 4;
           //Calculate the relative direction by adding the difference to IRobot.AHEAD. Modulo 4 as there are 4 directions.
           return relativeDirection;
       }
   
       private void doRecordJunction(IRobot robot){
           if(calcNumExits(robot,IRobot.BEENBEFORE) <=1){ //If been before exit <= 1, the junction is unexplored
               robotData.recordJunction(robot); //Only record junction if the junction is unexplored
           }
       }
   
       private int nonWallExits(IRobot robot){ //returns the number of non-WALL squares adjacent to the square currently occupied.
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterates through each relative direction
               if(robot.look(direction) != IRobot.WALL){ //For each direction, check if an exit lies ahead
                   numExits++; //If an exit lies ahead, increment the number of exits
               }
           }
           return numExits;
       }
   
       private int calcNumExits(IRobot robot, int exitType){ //Pass in an exit type and it calculates how many exits of that type are around the robot
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) == exitType){ //For each direction, check if there is a path matching exitType
                   numExits++; //Increment if there is a matching path.
               }
           }
           return numExits;
       }
   
       private int moveDeadEnd(IRobot robot){
           //Check each direction for the exit. Cannot just reverse direction, as robot could be facing any direction at the start
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collision
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveDeadEnd");
           /*As there should always be an exit that the robot can travel down at a dead end,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveCorridor(IRobot robot){
           //Check all directions apart from behind. Robot should not reverse direction when travelling along a corridor
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               if(direction != IRobot.BEHIND && robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collisin
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveCorridor");
           /*As there should always be >= 1 exit that the robot can travel down in a corridor,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveJunction(IRobot robot){
           ArrayList<Integer> nonWallExitsList = new ArrayList<Integer>();
           ArrayList<Integer> passagesList = new ArrayList<Integer>();
           //List of the passages that the robot has not yet been explored
   
           int pathType; //e.g. IRobot.BEENBEFORE or IRobot.PASSAGE
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               pathType = robot.look(direction); //Get the type of path at the current direction.
   
               if(pathType == IRobot.PASSAGE){ //If the path is a passage add it to passages list
                   passagesList.add(direction);
               }
               else if(pathType != IRobot.WALL){ //If the path is an exit add it to the nonWallExitsList
                   nonWallExitsList.add(direction);
               }
           }
           if(passagesList.size()>0){ //If there is a passage exit:
               return(chooseRandomExit(passagesList)); //Choose a random exit out of all the passages and return that direction
           }
           else{ //If there are no unexplored passages, pick a random exit from all the nonWallExits.
               return(chooseRandomExit(nonWallExitsList));
           }
       }
   
       private int chooseRandomExit(ArrayList<Integer>exitList){
           //Takes in an array and returns a random element in that array.
           Random rand = new Random();
           return(exitList.get(rand.nextInt(exitList.size()))); //Chooses a random index from 0 to the (length of the array - 1)
       }
   
       public void reset() {
           robotData.resetJunctionCounter();
           explorerMode = true; //Reset explorerMode so that the robot will be in explore mode next run.
           pollRun = 0; //Reset the number of polls this run.
       }
   }
   
   class RobotData{
       private HashMap<Integer, String> hashMapHeadings; //Used to convert headings to strings. IRobot.SOUTH -> 'SOUTH'
       private int junctionCounter = 0; //Represents the last index of the ArrayList
       ArrayList<JunctionRecorder> arrayOfJunctionRecorders;
       /*I chose an arrayList to hold the junctionRecorders, as new junctionRecoders are being added with every junction that is found.
       If an array with 10,000 max junctions were used (as in the guide), there would typically be a large amount of wasted space in the array,
       as it is very unlikely that the number of junctions encountered would reach near 10,000. */
   
       RobotData(){ //Class Constructor
           this.arrayOfJunctionRecorders = new ArrayList<JunctionRecorder>();
           createHeadingsHashMap(); //Create the hashMap for headings.
       }
   
       public void recordJunction(IRobot robot){
           this.arrayOfJunctionRecorders.add(new JunctionRecorder(robot.getLocation().x,robot.getLocation().y,robot.getHeading()));
           //Add a new junctionRecorder to the ArrayList, passing in the coordinates and heading of the robot as the properties of the junction.
           printJunction(junctionCounter); //print the details of the newly encountered junction
           junctionCounter++; //Increment the junction counter for when another junction is encountered.
       }
   
       public void resetJunctionCounter(){
           junctionCounter = 0; //Reset the index of the arraylist to 0
           arrayOfJunctionRecorders.clear(); //Remove all items from the collection.
           System.out.println("Resetting junction counter");
       }
   
       private void printJunction(int indexOfJunctionRecorder){
           JunctionRecorder CurrentJunctionRecorder = arrayOfJunctionRecorders.get(indexOfJunctionRecorder);
           //Get the junction recorder specifies by the indexOfJunctionRecorder paramter
   
           int CurrentJuncX = CurrentJunctionRecorder.getJuncX();
           int CurrentJuncY = CurrentJunctionRecorder.getJuncY();
           String CurrentHeadingArrivedFrom = hashMapHeadings.get(CurrentJunctionRecorder.getHeadingArrived());
           //Uses the hashmap to converting headings to strings e.g. IRobot.NORTH --> 'NORTH'
   
           System.out.printf("Junction %d (x=%d,y=%d) heading %s \n", indexOfJunctionRecorder,CurrentJuncX,CurrentJuncY,CurrentHeadingArrivedFrom);
       }
   
       private void createHeadingsHashMap(){
           hashMapHeadings = new HashMap<Integer, String>(){ //Creates a hashmap with integers as the key (e.g. IRobot.NORTH) and string as the value (e.g. 'NORTH')
               {
                   put(IRobot.NORTH, "NORTH");
                   put(IRobot.EAST, "EAST");
                   put(IRobot.SOUTH, "SOUTH");
                   put(IRobot.WEST, "WEST");
               }
           };
       }
   
       public int searchJunction(int juncX, int juncY){ //Returns heading of robot when the junction was first encountered
           //Search through array of junction recorders, starting at the most recently encountered junctions.
           //The junction is more likely to be at the end of the list so start there and iterate back through the array
           JunctionRecorder juncToCompare;
   
           for (int i = this.arrayOfJunctionRecorders.size()-1; i >= 0; i--) { //Iterates through each junction starting with most recently encountered
               juncToCompare = arrayOfJunctionRecorders.get(i);
               if (juncToCompare.getJuncX() == juncX && juncToCompare.getJuncY() == juncY)  {//If the X and Y coordinates match
                   return juncToCompare.getHeadingArrived(); //Return the heading that the robot arrived from
               }
           }
   
           throw new AssertionError("unreachable code reached in searchJunction (no junction found)");
           /*If in backtracking mode and the robot reaches a junction, it should be in the list of encountered junctions.
           So if no junction can be found in the arrayList, even though the robot should have visited it before, a serious error has occured*/
       }
   }
   
   class JunctionRecorder{ //Holds data for one junction that the robot has encountered
       private int juncX;
       private int juncY;
       private int headingArrived;
   
       JunctionRecorder(int x, int y, int headingArrived){ //Constructor function takes in the x and y of the junction, along with the heading the robot arrived at.
           this.setJunctionLocation(x, y);
           this.setHeadingArrived(headingArrived);
       }
   
       private void setJunctionLocation(int x, int y){
           this.juncX = x;
           this.juncY = y;
       }
   
       private void setHeadingArrived(int heading){
           this.headingArrived = heading;
       }
   
       //The following subroutines are public as they will be accessed from the RobotData class.
       public int getJuncX(){
           return juncX;
       }
   
       public int getJuncY(){
           return juncY;
       }
   
       public int getHeadingArrived(){
           return headingArrived; //Get the heading that the robot first arrived at the junction
       }
   }
