
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer5.java:

Program Listing for File Explorer5.java
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Explorer5.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Explorer5.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   import uk.ac.warwick.dcs.maze.logic.IRobot;
   import java.util.ArrayList;
   import java.util.Random;
   import java.util.HashMap;
   
   public class Explorer{
   
       private int pollRun = 0;
       private RobotData robotData;
       private int explorerMode;
   
       public void controlRobot(IRobot robot){
   
           initRobotData(robot); //Creates the RobotData class if this is the first run
   
           int directionToMove;
           CalculateReverseOfHeading(IRobot.WEST);
   
           if (explorerMode == 1){
               directionToMove = exploreControl(robot);
           }else{
               directionToMove = backtrackControl(robot);
           }
   
           robot.face(directionToMove);
       }
   
       private int exploreControl(IRobot robot){ //Returns the direction the robot should move in based on how many exits surround the robot
           int numExits = nonWallExits(robot); //Calculate number of exits
   
           switch (numExits){
               case 1:
                   explorerMode = 0;
                   return(moveDeadEnd(robot)); //moveDeadEnd returns the direction to move. This is returned to the main controlRobot subroutine
               case 2:
                   return(moveCorridor(robot)); //moveCorridor returns the direction to move
               case 3:
                   DoRecordJunction(robot); //As the robot has reached a junction, record the junction data in the Robot Data class
                   return(moveJunction(robot)); //moveJunction returns the direction to move
               default:
                   DoRecordJunction(robot);
                   return(moveCrossroads(robot)); //moveCrossroads returns the direction to move
           }
   
       }
   
       private int backtrackControl(IRobot robot){
           int numExits = nonWallExits(robot); //Calculate number of exits
           int numPassageExits;
   
           if(numExits > 2){ //Robot at junction or crossroad
               numPassageExits = passageExits(robot);
               if (numPassageExits > 0){
                   explorerMode = 1;
                   exploreControl(robot); //Call the explorer control function, as back in explorer mode
               }
               else{ //Exit the junction the opposite way that the robot entered
   
               }
           }
           return 0;
       }
   
       private int CalculateReverseOfHeading(int heading){
           //If travelling south the robot would have arrived from north, so add 2 to the heading arrived from
           //Then moduli 4 as there are 4 directions. Otherwise e.g. IRobot.WEST + 2 would not result in a valid direction.
           return (IRobot.NORTH + (heading + 2) % 4);
       }
   
       private void initRobotData(IRobot robot){
           if((robot.getRuns() == 0) && pollRun == 0){ //Only create a robot data class if this is the first run and the first time controlRobot has been polled
               robotData = new RobotData();
               explorerMode = 1; //Robot starts in explorer mode
               System.out.println("Creating the RobotData class");
           }
           pollRun++; //Increment the pollRun variable to avoid a new RobotData class being created next poll.
       }
   
   
       private void DoRecordJunction(IRobot robot){
           if(beenbeforeExits(robot) <=1){ //If been before exit <= 1 , the junction is unexplored
               robotData.RecordJunction(robot); //Only record junction if the junction is unexplored
           }
       }
   
       private int nonWallExits(IRobot robot){
           //returns the number of non-WALL squares adjacent to the square currently occupied.
   
           int numExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterates through each relative direction
               if(robot.look(direction) != IRobot.WALL){ //For each direction, check if an exit lies ahead
                   numExits++; //If an exit lies ahead, increment the number of exits
               }
           }
           return numExits;
       }
   
       private int beenbeforeExits(IRobot robot){
           //returns the number of non-WALL squares adjacent to the square currently occupied.
   
           int numBeenBefore = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) == IRobot.BEENBEFORE){ //For each direction, check if the robot has been there before
                   numBeenBefore++; //Increment if robot has been there before
               }
           }
           return numBeenBefore;
       }
   
       private int passageExits(IRobot robot){
           //returns the number of passage squares adjacent to the square currently occupied.
   
           int numPassageExits = 0;
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) == IRobot.PASSAGE){ //For each direction, check if there is a passage
                   numPassageExits++; //Increment if there is a passage
               }
           }
           return numPassageExits;
       }
   
       private int moveDeadEnd(IRobot robot){
           /*Check each direction for the exit
           Cannot just reverse direction, as robot could be facing any direction
           at the start*/
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) { //Iterate through each direction
               if(robot.look(direction) != IRobot.WALL){ //Find the direction that will not cause a collision
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveDeadEnd");
           /*As there should always be an exit that the robot can travel down at a dead end,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveCorridor(IRobot robot){
           //Check all directions apart from behind. Robot should not reverse direction when travelling along a corridor
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               if(direction != IRobot.BEHIND && robot.look(direction) != IRobot.WALL){
                   return direction;
               }
           }
   
           throw new AssertionError("unreachable code reached in moveCorridor");
           /*As there should always be >= 1 exit that the robot can travel down in a corridor,
           this error can only occur if there has been a fatal error in the maze environment*/
       }
   
       private int moveJunction(IRobot robot){
           ArrayList<Integer> nonWallExitsList = new ArrayList<Integer>();
           ArrayList<Integer> passagesList = new ArrayList<Integer>();
           //List of the passages that the robot has not yet been explored
   
           int pathType; //e.g. IRobot.BEENBEFORE or IRobot.PASSAGE
   
           for (int direction = IRobot.AHEAD; direction <= IRobot.LEFT; direction++) {
               pathType = robot.look(direction);
   
               if(pathType == IRobot.PASSAGE){
                   passagesList.add(direction);
               }
               else if(pathType != IRobot.WALL){
                   nonWallExitsList.add(direction);
               }
           }
           if(passagesList.size()>0){
               return(chooseRandomExit(passagesList)); //Choose a random exit out of all the passages
           }
           else{ //If there are no unexplored passages, pick a random exit from all the nonWallExits.
               return(chooseRandomExit(nonWallExitsList));
           }
       }
   
       private int chooseRandomExit(ArrayList<Integer>exitList){
           //Returns a random element of the exit array
           Random rand = new Random();
           return(exitList.get(rand.nextInt(exitList.size())));
       }
   
       private int moveCrossroads(IRobot robot){
           return(moveJunction(robot));
           /*Currently move junction and move crossroads can be achieved
           with the same method*/
       }
   
       public void reset() {
           robotData.resetJunctionCounter();
           explorerMode = 1; //Reset explorerMode so that the robot will be in explore mode next run.
       }
   }
   
   class RobotData{
       private HashMap<Integer, String> hashMapHeadings;
       private int junctionCounter = 0; //Represents the last index of the erray
       ArrayList<JunctionRecorder> arrayOfJunctionRecorders;
       /*I chose an arrayList to hold the junctionRecorders, as new junctionRecoders are being added with every junction that is found.
       If an array with 10,000 max junctions were used (as in the guide), there would typically be a large amount of wasted space in the array,
       as it is very unlikely that the number of junctions encountered would reach near 10,000. */
   
       RobotData(){ //Class Constructor
           this.arrayOfJunctionRecorders = new ArrayList<JunctionRecorder>();
           CreateHashMap(); //Create the hashMap for headings.
       }
   
       public void RecordJunction(IRobot robot){
           this.arrayOfJunctionRecorders.add(new JunctionRecorder(robot.getLocation().x,robot.getLocation().y,robot.getHeading()));
           //Add a new junctionRecorder to the ArrayList, passing in the coordinates and heading of the robot as the properties of the junction.
   
           printJunction(junctionCounter);
   
           junctionCounter++;
       }
   
       public void resetJunctionCounter(){
           junctionCounter = 0; //Reset the index of the arraylist to 0
           arrayOfJunctionRecorders.clear(); //Remove all items from the collection.
           System.out.println("Resetting junction counter");
       }
   
       private void printJunction(int indexOfJunctionRecorder){
           JunctionRecorder CurrentJunctionRecorder = arrayOfJunctionRecorders.get(indexOfJunctionRecorder);
   
           int CurrentJuncX = CurrentJunctionRecorder.getJuncX();
           int CurrentJuncY = CurrentJunctionRecorder.getJuncY();
           String CurrentHeadingArrivedFrom = hashMapHeadings.get(CurrentJunctionRecorder.getHeadingArrived());
           //Uses the hashmap to converting headings to strings e.g. IRobot.NORTH --> 'NORTH'
   
           System.out.printf("Junction %d (x=%d,y=%d) heading %s \n", indexOfJunctionRecorder,CurrentJuncX,CurrentJuncY,CurrentHeadingArrivedFrom);
       }
   
       private void CreateHashMap(){
           hashMapHeadings = new HashMap<Integer, String>(){
               {
                   put(IRobot.NORTH, "NORTH");
                   put(IRobot.EAST, "EAST");
                   put(IRobot.SOUTH, "SOUTH");
                   put(IRobot.WEST, "WEST");
               }
           };
       }
   
       private int searchJunction(int juncX, int juncY){ //Returns heading of robot when the junction was first encountered
           //Search through array of junction recorders, starting at the most recently encountered junctions.
           //The junction is more likely to be at the end of the list so start there and iterate back through the array
   
           JunctionRecorder juncToCompare;
   
           for (int i = this.arrayOfJunctionRecorders.size()-1; i >= 0; i-- ) {
               juncToCompare = arrayOfJunctionRecorders.get(i);
               if (juncToCompare.getJuncX() == juncX && juncToCompare.getJuncY() == juncY)  {
                   return juncToCompare.getHeadingArrived();
               }
           }
   
           throw new AssertionError("unreachable code reached in searchJunction (no junction found)");
           /*If in backtracking mode and the robot reaches a junction, it should be in the list of encountered junctions.
           So if no junction can be found in the arrayList, even though the robot should have visited it before, a serious error has occured*/
   
       }
   }
   
   class JunctionRecorder{
       private int juncX;
       private int juncY;
       private int headingArrived;
   
       JunctionRecorder(int x, int y, int headingArrived){
           this.setJunctionLocation(x, y);
           this.setHeadingArrived(headingArrived);
       }
   
       private void setJunctionLocation(int x, int y){
           this.juncX = x;
           this.juncY = y;
       }
   
       private void setHeadingArrived(int heading){
           this.headingArrived = heading;
       }
   
       public int getJuncX(){
           return juncX;
       }
   
       public int getJuncY(){
           return juncY;
       }
   
       public int getHeadingArrived(){
           return headingArrived;
       }
   }
