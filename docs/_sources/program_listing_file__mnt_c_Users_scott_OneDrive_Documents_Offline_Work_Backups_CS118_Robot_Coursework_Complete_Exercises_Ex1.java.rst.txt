
.. _program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Ex1.java:

Program Listing for File Ex1.java
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Ex1.java>` (``/mnt/c/Users/scott/OneDrive/Documents/Offline Work/Backups/CS118 Robot Coursework/Complete Exercises/Ex1.java``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: java

   /*
   Preamble: The robot avoids collisions by detecting whether a wall is blocking the chosen direction.
   If there is a wall blocking that direction, a new direction is chosen until there is not a wall in the way.
   For checking whether the robot is at a deadend/corridor/junction/crossroads, I created a separate function to
   determine the number of walls directly adjacent to the robot, using the IRobot.look() function.
   */
   
   import uk.ac.warwick.dcs.maze.logic.IRobot;
   
   public class Ex1
   {
   
       public void controlRobot(IRobot robot) {
   
           int randno;
           int direction;
           String directionString;
           byte numWallsAroundRobot;
           String pathType;
   
           //Calculate the number of walls that are directly around the IRobot
           //This is used to determine whehter the robot is at a corridor, junction, crossroads or deadend
           numWallsAroundRobot = ReturnWallsAroundRobto(robot);
           pathType = DeterminePathType(numWallsAroundRobot);
   
   
           do{
               randno = (int) Math.round(Math.random()*3);
               switch (randno){ //Direction chosen based on random number
                   case 0:
                       direction = IRobot.LEFT;
                       directionString = "left";
                       break;
                   case 1:
                           direction = IRobot.RIGHT;
                           directionString = "right";
                           break;
                   case 2:
                           direction = IRobot.BEHIND;
                           directionString = "backwards";
                           break;
                   default:
                           direction = IRobot.AHEAD;
                           directionString = "forwards";
                           break;
               }
           } while(robot.look(direction) == IRobot.WALL);
           //Choose a direction again if the robot is facing a wall
   
           robot.face(direction); /* Face the robot in this direction */
           System.out.println("I'm going "  + directionString + pathType );
       }
   
       public String DeterminePathType(byte numWalls){
           //The path type is determined based on the number of walls surrounding the robot
               switch (numWalls){
                   case 0:
                           return(" at a crossroads");
                   case 1:
                           return(" at a junction");
                   case 2:
                           return(" along a corridor");
                   default:
                           return(" at a dead end");
               }
       }
   
       public byte ReturnWallsAroundRobto(IRobot robot){
               byte numWalls = 0;
               int direction = IRobot.AHEAD;
               for (byte i=0; i<=3 ; i++ ) {
   
                   if(robot.look(direction) == IRobot.WALL){
                       //If there is a wall in the current direction increment the number of walls
                       numWalls++;
                   }
                   direction++;
               }
               return numWalls;
       }
   
   
   
   }
