<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File README.md &mdash; Python  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Program Listing for File README.md</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File README.md</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/program_listing_file__mnt_c_Users_scott_OneDrive_Desktop_New_folder_New_folder_README.md.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-readme-md">
<span id="program-listing-file-mnt-c-users-scott-onedrive-desktop-new-folder-new-folder-readme-md"></span><h1>Program Listing for File README.md<a class="headerlink" href="#program-listing-for-file-readme-md" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file__mnt_c_Users_scott_OneDrive_Desktop_New_folder_New_folder_README.md.html#file-mnt-c-users-scott-onedrive-desktop-new-folder-new-folder-readme-md"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">/mnt/c/Users/scott/OneDrive/Desktop/New</span> <span class="pre">folder/New</span> <span class="pre">folder/README.md</span></code>)</p>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span>One minor aspect of the schema that could be optimised is that cost is repeated in gig_ticket and ticket. In an ideal implementation, it would be better to have ticket.pricetype referencing gig_ticket.pricetype. In this way, the cost of a ticket could be found by joining ticket and gig_ticket, meaning ticket.cost is not required.

Another possible change could be to store the offtime instead of duration in act_gig, as the offtime property is used far more often than duration. This would remove repeatedly recalculating the offtime for each act when performing queries. For checking an act is onstage for less than 2 hours, the duration can still be calculated with offtime - ontime.

For this specific coursework, the members field and the genre fields of act are never used, so it could be removed without affecting any of the query results. In addition, as actname is guaranteed to be unique (from the FAQ), we could also remove the actID field and use actname as the primary key for act, reducing the number of fields used. A similar optimisation can be applied to venuename and venueid.

The cost of an arbitrary ticket/actfee/hirecost may not necessarily be a whole integer, so the type of these fields should be changed to MONEY or NUMERIC instead.


Constraint Checks
   <span class="k">-</span> The majority of constraint checking is performed within triggers. For example, when a new act is inserted, the check_act_timings() function will be triggered. This function raises an exception if a constraint is violated, which will be handled in the Java subroutine. In option 2, if an act_gig is invalid, we rollback the data to the last valid state, which is before the new gig was inserted.

Option 1
   <span class="k">-</span> To get the gig line up for a given gigID, option 1 simply joins act, act_gig and gig together, which allows the actname and ontime to be output. To get the offtime for an act, we use offtime = ontime + duration.
   <span class="k">-</span> The results are ordered by ontime ascending.

Option 2
   <span class="k">-</span> In organise_new_gig, the gig&#39;s properties are inserted into a new row in the gig table. I created an auxilliary function, get_venue_id_from_name, to get the venue id from the given venue name
   <span class="k">-</span> Then for each act in the gig, the Java subroutine calls insert_new_act_gig, which adds a single act_gig to the table
   <span class="k">-</span> Notably, after the gig and all its corresponding acts have been inserted, the Java option calls check_gig_gaps_less_than_20_mins, to check that no constraints have been violated. This procedure checks that any breaks in the lineup are &lt; 20 mins long and the first act&#39;s ontime is within 20 minutes of the gig start time. If one of these constraints are violated, an exception will be thrown, which is handled in a catch clause of the Java function. In this example, the database is rolled back to before the gig was added.

Option 3
   <span class="k">-</span> To book a ticket, first we must check that the gig exists and that the ticket type is valid. Therefore if there are any errors, the database state is as it was
   before the method was called.
   <span class="k">-</span> Then we simply can get the corresponding ticket cost for the given ticket type, and insert a new row into the ticket table.

Option 4
   <span class="k">-</span> To cancel an act, we first check if the act is the headliner of the gig and store this in a boolean variable. We then remove the act_gig with actid and gigID matching the provided IDs. Furthermore, we also make a call to the check_gig_gaps_less_than_20_mins function, because we must ensure that database state is maintained correctly after this act has been cancelled. If we determined that the act is headlining or a check_gig_gaps_less_than_20_mins indicated a constraint was violated (e.g. cancelling act would cause &gt; 20 minute gap, then we know the gig must also be cancelled and we can call cancel_gig().

Option 5
   <span class="k">-</span> We decided to split option 5 into small subroutines that get the required properties to calculate the tickets needed to sell:
     <span class="k">-</span> get_venue_fee_for_gig gets the venue fee for a given gig
     <span class="k">-</span> get_agreed_fees_for_gig gets the agreed act fees for a given gig by summing up all the act fees
     <span class="k">-</span> get_value_of_tickets_sold_for_gig sums all the ticket costs sold so far which match the provided gigID
     <span class="k">-</span> get_standard_ticket_price obtains the standard ticket price for an arbitrary gig
     <span class="k">-</span> get_tickets_needed_to_sell_for_gig calculates the tickets needed to sell to at least cover the venue fees and act fees for a SINGLE gig using the above functions. It uses the following formula to find the tickets still needed to be sold: MAX[CEIL((venue_fee + agreed_fees - tickets_already_sold) / standard_ticket_price), 0]. The max function is included as if the gig has already met the ticket quota to become profitable, then no further tickets need to be sold.
     <span class="k">-</span> get_tickets_needed_to_sell_for_all_gigs will call get_tickets_needed_to_sell_for_gig to find the tickets needed to sell for EVERY gig.

Option 6
   <span class="k">-</span> First get all the headline acts for each gig
   <span class="k">-</span> Then calculate a rank column, which is used for ordering an act based on total ticket sales over the years
   <span class="k">-</span> Then group all the tickets by the actID and year, to get the total sales for an act for each year
   <span class="k">-</span> UNION this with grouping the tickets by just actID, to get the total sales for an act over ALL years.
   <span class="k">-</span> The ordering column calculated previously is added to both sets before the UNION operation, which is used to order the acts by total ticket sales, then by year.

Option 7
   <span class="k">-</span> First join the tickets with act_gig table and act table where the act is a headliner
   <span class="k">-</span> Then get the distinct years where each act has played as a headliner
   <span class="k">-</span> Then Get the NUMBER (i.e count) of distinct years where act has headlined. For instance, if a act has played in 2017, 2018 and 2020, this count would be 3.
   <span class="k">-</span> Using the first CTE, get NUMBER of distinct years where customer has been to a concert with the act headlining.
   <span class="k">-</span> Then perform a LEFT JOIN on the third and fourth CTEs. Importantly, the join must using actname AND the number of concerts given / attended (the count column), to get the act-customer pairs where the customer has been to a concert each calender year. The LEFT JOIN means acts that do not have a customer that has been to a concert each calender year, are still present in the final results table.

Option 8
   <span class="k">-</span> To get the economically feasible gigs, we first CROSS JOIN acts with venues before filtering out non-economically viable gigs in a WHERE clause. In the WHERE clause we use venue.capacity * avg_ticket_price &gt;= act.standardfee + venue.hirecost to only include gigs that would be profitable (assuming all tickets sold). To calculate the number of tickets needed to cover the fees, we used: tickets_required = CEIL((act.standardfee + venue.hirecost) / avg_ticket_price). Then, for ordering the results based on the proportion of tickets that need to be sold, we used added a rank column r = tickets_required/venue.capacity. The query is order by venuename then by descending order of the rank.
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>