<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File GrandFinale.java &mdash; Python  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Program Listing for File GrandFinale.java</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File GrandFinale.java</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/program_listing_file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Coursework_2_complete_GrandFinale.java.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-grandfinale-java">
<span id="program-listing-file-mnt-c-users-scott-onedrive-documents-offline-work-backups-cs118-robot-coursework-complete-exercises-coursework-2-complete-grandfinale-java"></span><h1>Program Listing for File GrandFinale.java<a class="headerlink" href="#program-listing-for-file-grandfinale-java" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file__mnt_c_Users_scott_OneDrive_Documents_Offline_Work_Backups_CS118_Robot_Coursework_Complete_Exercises_Coursework_2_complete_GrandFinale.java.html#file-mnt-c-users-scott-onedrive-documents-offline-work-backups-cs118-robot-coursework-complete-exercises-coursework-2-complete-grandfinale-java"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">/mnt/c/Users/scott/OneDrive/Documents/Offline</span> <span class="pre">Work/Backups/CS118</span> <span class="pre">Robot</span> <span class="pre">Coursework/Complete</span> <span class="pre">Exercises/Coursework</span> <span class="pre">2</span> <span class="pre">complete/GrandFinale.java</span></code>)</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Grand Finale Preamble: For the Grand Finale, I decided to modify my code for Ex2, as only a few small modifications were needed,</span>
<span class="cm">so that the robot could record the fastest route. This means my robot uses a method very similar to Route B as described in the guide.</span>

<span class="cm">In addition to my solution for Ex2, my program uses another stack to record the heading that the robot left each junction. When the</span>
<span class="cm">robot arrives at a previously unencountered junction, the robot pushes the next chosen heading to the top of the stack.</span>
<span class="cm">If a junction is backtracked through, that junction is not part of the final route to the target (as all of its exits have been</span>
<span class="cm">explored), so the corresponding heading is popped from the top of the stack.</span>

<span class="cm">I added a retraceControl method, that handles movement on repeat runs of the same maze. The method simply gets each heading in</span>
<span class="cm">the finalRouteStack sequentially, and uses that to direct the robot straight to the target using the quickest route.</span>

<span class="cm">To deal with new mazes, I used the IEvent and EventBus libraries so that my controller can receive events from the maze environment</span>
<span class="cm">itself. When a new maze is loaded in, the EventClient class can receive event codes from the notify function. Each button in the maze</span>
<span class="cm">environment sends a different code, so if an event is received and the event message is 115, for example, then a new maze has</span>
<span class="cm">been loaded in from a file. Upon a new maze being loaded in, my program clears the junctionStack and the finalRoute stack, and</span>
<span class="cm">resets all the variables.</span>

<span class="cm">Like my solution for Ex2, my robot does not reliably solve loopy mazes. As junctions can be visited multiple times when the robot</span>
<span class="cm">goes round a loop, the headings are not properly ejected from the stack, as the robot does not always backtrack through the junction. Therefore,</span>
<span class="cm">if the user selects a generator that creates mazes with loops, I output a message to the console telling the user that this ‘controller</span>
<span class="cm">does not find the quickest route in mazes with loops’. I used the EventBus again to detect when a new generator is selected, and</span>
<span class="cm">compare the name of the new generator to a list of disallowedGenerators. If the new Generator is in this list, I output the warning</span>
<span class="cm">message to the user.</span>
<span class="cm">*/</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.logic.IRobot</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.ArrayList</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Random</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.HashMap</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Set</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.logic.IEventClient</span><span class="p">;</span><span class="w"> </span><span class="c1">//Import the Event libraries so that the controller can receive events from the maze environment</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.logic.IEvent</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.logic.Event</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.logic.EventBus</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.logic.IMazeGenerator</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uk.ac.warwick.dcs.maze.generators.*</span><span class="p">;</span><span class="w"> </span><span class="c1">//Import maze.generators so that the program can check if the user has selected a loopy generator</span><span class="w"></span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">GrandFinale</span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pollRun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">RobotData</span><span class="w"> </span><span class="n">robotData</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">explorerMode</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">atJunction</span><span class="p">;</span><span class="w"> </span><span class="c1">//If the robot is at a junction, record the heading chosen.</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">retrace</span><span class="p">;</span><span class="w"> </span><span class="c1">//Is the robot retracing for repeat run of the same maze</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">retraceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Represents the current index of the finalRouteStack (used for repeat runs of the same maze)</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">EventClient</span><span class="w"> </span><span class="n">eventClient</span><span class="p">;</span><span class="w"> </span><span class="c1">//Class used to receive events from the maze environment through the EventBus.</span><span class="w"></span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">controlRobot</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">directionToMove</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">initRobotData</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Creates the RobotData class if this is the first run</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">retrace</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">directionToMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">retraceControl</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">directionToMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">explorerAndBacktrackControl</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">atJunction</span><span class="p">){</span><span class="w"> </span><span class="c1">//If the robot is at a junction, record the heading that was chosen in the final route stack.</span><span class="w"></span>
<span class="w">            </span><span class="n">recordFinalRouteHeading</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="n">directionToMove</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">robot</span><span class="p">.</span><span class="na">face</span><span class="p">(</span><span class="n">directionToMove</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>


<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">explorerAndBacktrackControl</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"> </span><span class="c1">//Controls explorerControl and backtrackControl</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">explorerMode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">true</span><span class="p">){</span><span class="w"> </span><span class="c1">//If explore mode on, call the exploreControl subroutine.</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">exploreControl</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">backtrackControl</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">initRobotData</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numRuns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">robot</span><span class="p">.</span><span class="na">getRuns</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">pollRun</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">//Robot starts in explorer mode</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">((</span><span class="n">numRuns</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)){</span><span class="w"> </span><span class="c1">//Only create a robot data class if this is the first run and the first time controlRobot has been polled this run</span><span class="w"></span>
<span class="w">                </span><span class="n">robotData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RobotData</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="n">initEventBus</span><span class="p">();</span><span class="w"> </span><span class="c1">//init event bus if this is the first run</span><span class="w"></span>
<span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Creating the RobotData class&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">numRuns</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">retrace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">//if this is the first run</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">pollRun</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//Increment the pollRun variable to avoid a new RobotData class being created next poll.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">initEventBus</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">eventClient</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">){</span><span class="w"> </span><span class="c1">//Only initialise the event client if the eventClient variable is empty</span><span class="w"></span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Inialising event bus&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">eventClient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">EventClient</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w"> </span><span class="c1">//Creates a new client</span><span class="w"></span>
<span class="w">            </span><span class="n">EventBus</span><span class="p">.</span><span class="na">addClient</span><span class="p">(</span><span class="n">eventClient</span><span class="p">);</span><span class="w"> </span><span class="c1">//Adds this newly created client to the event bus, so my controller can receive notifications.</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">retraceControl</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonWallExits</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Calculate number of exits</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">numExits</span><span class="w"> </span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">exploreControl</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//If at a deadend/corridor simply use exploreControl to determine the valid exit</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">directionToMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertHeadingToRelativeDirection</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="n">robotData</span><span class="p">.</span><span class="na">retraceGetNextHeading</span><span class="p">(</span><span class="n">retraceIndex</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="c1">// directionToMove is the next heading in the stack converted to a relative direction</span><span class="w"></span>
<span class="w">            </span><span class="n">retraceIndex</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//increment the retrace index to look at the next index in the finalRouteStack</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">directionToMove</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">exploreControl</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"> </span><span class="c1">//Returns the direction the robot should move in based on how many exits surround the robot</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonWallExits</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Calculate number of exits</span><span class="w"></span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">numExits</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">pollRun</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">){</span><span class="w"> </span><span class="c1">//Only set to backtrack if not at the start of maze. If started at a dead end, still should be in explore mode.</span><span class="w"></span>
<span class="w">                    </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">(</span><span class="n">moveDeadEnd</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//moveDeadEnd returns the direction to move. This is returned to the main controlRobot subroutine</span><span class="w"></span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">(</span><span class="n">moveCorridor</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="k">default</span><span class="p">:</span><span class="w"> </span><span class="c1">//Moving at crossroads (4 exits) and at junctions (3 exits) can be executed by the same code</span><span class="w"></span>
<span class="w">                </span><span class="n">doRecordJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//As the robot has reached a junction, record the junction data in the Robot Data class</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">(</span><span class="n">moveJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">backtrackControl</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonWallExits</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Calculate number of exits</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">numExits</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">){</span><span class="w"> </span><span class="c1">//Robot at junction or crossroad</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">backtrackAtJunctionCrossroads</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"> </span><span class="c1">//If there are less than or equal to 2 exits, we can just use the exploreControl to select the appropriate move for at a dead end / corridor.</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">exploreControl</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//This saves the need for an extra subroutine for backtracking at corridors and junctions.</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">backtrackAtJunctionCrossroads</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"> </span><span class="c1">//Handles the backtracking if the robot is at a junction or at crossroads.</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numPassageExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calcNumExits</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span><span class="n">IRobot</span><span class="p">.</span><span class="na">PASSAGE</span><span class="p">);</span><span class="w"> </span><span class="c1">//Calculate the number of passage exits.</span><span class="w"></span>

<span class="w">        </span><span class="n">robotData</span><span class="p">.</span><span class="na">popFinalRouteStack</span><span class="p">();</span><span class="w"> </span><span class="c1">//finalRouteStack popped as a new move will be chosen for this junction</span><span class="w"></span>
<span class="w">        </span><span class="n">robotData</span><span class="p">.</span><span class="na">printStack</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">numPassageExits</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"> </span><span class="c1">//If there is an unexplored passage, switch back into explorer mode.</span><span class="w"></span>
<span class="w">            </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">atJunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">//If there is a passage record the heading that the robot moves for the final route stack</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">exploreControl</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"> </span><span class="c1">//Call the explorer control function to determine the move, as explorer mode has been activated</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"> </span><span class="c1">//Exit the junction the opposite way that the robot entered</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">exitJunctionReverse</span><span class="p">(</span><span class="n">robot</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">recordFinalRouteHeading</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="p">){</span><span class="w"> </span><span class="c1">//When at a junction, add the heading moved to the final route stack</span><span class="w"></span>
<span class="w">        </span><span class="n">robotData</span><span class="p">.</span><span class="na">recordChosenHeading</span><span class="p">(</span><span class="n">convertRelativeDirectionToHeading</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">));</span><span class="w"> </span><span class="c1">//convert the direction to a heading and record</span><span class="w"></span>
<span class="w">        </span><span class="n">atJunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">//no longer at a junction</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">exitJunctionReverse</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"> </span><span class="c1">//Exit the junction the opposite way to which the robot was heading when it found the junction the first time.</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">headingEnteredJunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">robotData</span><span class="p">.</span><span class="na">searchJunction</span><span class="p">();</span><span class="w"> </span><span class="c1">//Get the top element from the stack.</span><span class="w"></span>
<span class="w">        </span><span class="n">robotData</span><span class="p">.</span><span class="na">printStack</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">reverseOfHeading</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculateReverseOfHeading</span><span class="p">(</span><span class="n">headingEnteredJunction</span><span class="p">);</span><span class="w"> </span><span class="c1">//Calculate reverse of the heading</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">directionToMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertHeadingToRelativeDirection</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="n">reverseOfHeading</span><span class="p">);</span><span class="w"> </span><span class="c1">//Convert the reverse of the heading to a relative direction, as my controlRobot uses relative directions to move.</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">directionToMove</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">calculateReverseOfHeading</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">heading</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">NORTH</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">heading</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="c1">//If travelling south the robot would have arrived from north, so add 2 to the heading arrived from</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Moduli 4 as there are 4 directions. Otherwise e.g. IRobot.WEST + 2 would not result in a valid direction.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">convertHeadingToRelativeDirection</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">heading</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">difference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heading</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">robot</span><span class="p">.</span><span class="na">getHeading</span><span class="p">();</span><span class="w"> </span><span class="c1">//get the difference between current heading and the heading to look</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">relativeDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">difference</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Calculate the relative direction by adding the difference to IRobot.AHEAD. Modulo 4 as there are 4 directions.</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">relativeDirection</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">convertRelativeDirectionToHeading</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">difference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="c1">//get the difference between current heading and the heading to look</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">heading</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">NORTH</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">getHeading</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">difference</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Calculate the relative direction by adding the difference to IRobot.AHEAD. Modulo 4 as there are 4 directions.</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">heading</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doRecordJunction</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">atJunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">//As at a junction, record the heading chosen</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">calcNumExits</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span><span class="n">IRobot</span><span class="p">.</span><span class="na">BEENBEFORE</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">){</span><span class="w"> </span><span class="c1">//If been before exit &lt;= 1, the junction is unexplored</span><span class="w"></span>
<span class="w">            </span><span class="n">robotData</span><span class="p">.</span><span class="na">recordJunction</span><span class="p">(</span><span class="n">robot</span><span class="p">);</span><span class="w"> </span><span class="c1">//Only record junction if the junction is unexplored</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">nonWallExits</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"> </span><span class="c1">//returns the number of non-WALL squares adjacent to the square currently occupied.</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Iterates through each relative direction</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"> </span><span class="c1">//For each direction, check if an exit lies ahead</span><span class="w"></span>
<span class="w">                </span><span class="n">numExits</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//If an exit lies ahead, increment the number of exits</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">numExits</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">calcNumExits</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">exitType</span><span class="p">){</span><span class="w"> </span><span class="c1">//Pass in an exit type and it calculates how many exits of that type are around the robot</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Iterate through each direction</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exitType</span><span class="p">){</span><span class="w"> </span><span class="c1">//For each direction, check if there is a path matching exitType</span><span class="w"></span>
<span class="w">                </span><span class="n">numExits</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//Increment if there is a matching path.</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">numExits</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">moveDeadEnd</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Check each direction for the exit. Cannot just reverse direction, as robot could be facing any direction at the start</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Iterate through each direction</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"> </span><span class="c1">//Find the direction that will not cause a collision</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;unreachable code reached in moveDeadEnd&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*As there should always be an exit that the robot can travel down at a dead end,</span>
<span class="cm">        this error can only occur if there has been a fatal error in the maze environment*/</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">moveCorridor</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Check all directions apart from behind. Robot should not reverse direction when travelling along a corridor</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">BEHIND</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"> </span><span class="c1">//Find the direction that will not cause a collisin</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;unreachable code reached in moveCorridor&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*As there should always be &gt;= 1 exit that the robot can travel down in a corridor,</span>
<span class="cm">        this error can only occur if there has been a fatal error in the maze environment*/</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">moveJunction</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nonWallExitsList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">passagesList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">//List of the passages that the robot has not yet been explored</span><span class="w"></span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pathType</span><span class="p">;</span><span class="w"> </span><span class="c1">//e.g. IRobot.BEENBEFORE or IRobot.PASSAGE</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">AHEAD</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">LEFT</span><span class="p">;</span><span class="w"> </span><span class="n">direction</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">pathType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">robot</span><span class="p">.</span><span class="na">look</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span><span class="w"> </span><span class="c1">//Get the type of path at the current direction.</span><span class="w"></span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">pathType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">PASSAGE</span><span class="p">){</span><span class="w"> </span><span class="c1">//If the path is a passage add it to passages list</span><span class="w"></span>
<span class="w">                </span><span class="n">passagesList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">pathType</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IRobot</span><span class="p">.</span><span class="na">WALL</span><span class="p">){</span><span class="w"> </span><span class="c1">//If the path is an exit add it to the nonWallExitsList</span><span class="w"></span>
<span class="w">                </span><span class="n">nonWallExitsList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">passagesList</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span><span class="w"> </span><span class="c1">//If there is a passage exit:</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">chooseRandomExit</span><span class="p">(</span><span class="n">passagesList</span><span class="p">));</span><span class="w"> </span><span class="c1">//Choose a random exit out of all the passages and return that direction</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"> </span><span class="c1">//If there are no unexplored passages, pick a random exit from all the nonWallExits.</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="p">(</span><span class="n">chooseRandomExit</span><span class="p">(</span><span class="n">nonWallExitsList</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">chooseRandomExit</span><span class="p">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="n">exitList</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Takes in an array and returns a random element in that array.</span><span class="w"></span>
<span class="w">        </span><span class="n">Random</span><span class="w"> </span><span class="n">rand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Random</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">(</span><span class="n">exitList</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">rand</span><span class="p">.</span><span class="na">nextInt</span><span class="p">(</span><span class="n">exitList</span><span class="p">.</span><span class="na">size</span><span class="p">())));</span><span class="w"> </span><span class="c1">//Chooses a random index from 0 to the (length of the array - 1)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">reset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">robotData</span><span class="p">.</span><span class="na">resetJunctionStack</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">explorerMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">//Reset explorerMode so that the robot will be in explore mode next run.</span><span class="w"></span>
<span class="w">        </span><span class="n">pollRun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Reset the number of polls this run.</span><span class="w"></span>
<span class="w">        </span><span class="n">retraceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">atJunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">resetFinalRoute</span><span class="p">(){</span><span class="w"> </span><span class="c1">//Clears the final route stack and resets the retracing variables</span><span class="w"></span>
<span class="w">        </span><span class="n">retrace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">retraceIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">robotData</span><span class="p">.</span><span class="na">resetFinalRouteStack</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">class</span> <span class="nc">RobotData</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hashMapHeadings</span><span class="p">;</span><span class="w"> </span><span class="c1">//Used to convert headings to strings. IRobot.SOUTH -&gt; &#39;SOUTH&#39;</span><span class="w"></span>
<span class="w">    </span><span class="n">Stack</span><span class="w"> </span><span class="n">junctionStack</span><span class="p">;</span><span class="w"> </span><span class="c1">//Stack which records the most recently encountered junctions at the top.</span><span class="w"></span>
<span class="w">    </span><span class="n">Stack</span><span class="w"> </span><span class="n">finalRouteStack</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//When arriving at a previously unencountered junction, it is pushed to the top of the stack.</span><span class="w"></span>
<span class="w">    </span><span class="c1">//Once a junction has been &#39;backtracked through&#39;, it is popped from the stack.</span><span class="w"></span>
<span class="w">    </span><span class="c1">//junctionStack - heading the robot arrived at the junction. finalRouteStack - heading robot left the junction</span><span class="w"></span>
<span class="w">    </span><span class="c1">//They are separate stacks as they both have to be cleared at different points in the program&#39;s execution.</span><span class="w"></span>

<span class="w">    </span><span class="n">RobotData</span><span class="p">(){</span><span class="w"> </span><span class="c1">//Class Constructor</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">junctionStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Stack</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">finalRouteStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Stack</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">createHeadingsHashMap</span><span class="p">();</span><span class="w"> </span><span class="c1">//Create the hashMap for headings.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">recordJunction</span><span class="p">(</span><span class="n">IRobot</span><span class="w"> </span><span class="n">robot</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">junctionStack</span><span class="p">.</span><span class="na">push</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">robot</span><span class="p">.</span><span class="na">getHeading</span><span class="p">());</span><span class="w"> </span><span class="c1">//push the robot&#39;s current heading to the stack.</span><span class="w"></span>
<span class="w">        </span><span class="c1">//Heading is cast to Short primitive type to save space, as headings are only in the range 1000-1003</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">recordChosenHeading</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">heading</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">finalRouteStack</span><span class="p">.</span><span class="na">push</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="n">heading</span><span class="p">);</span><span class="w"> </span><span class="c1">//Push the heading to the finalRouteStack</span><span class="w"></span>
<span class="w">        </span><span class="n">printStack</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">resetJunctionStack</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">junctionStack</span><span class="p">.</span><span class="na">clearStack</span><span class="p">();</span><span class="w"> </span><span class="c1">//Remove all elements from the stack so that a new run can be started.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">resetFinalRouteStack</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">finalRouteStack</span><span class="p">.</span><span class="na">clearStack</span><span class="p">();</span><span class="w"> </span><span class="c1">//Remove all elements from the stack so that a new run can be started.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">searchJunction</span><span class="p">(){</span><span class="w"> </span><span class="c1">//Returns heading of robot when the junction was first encountered</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">(</span><span class="n">junctionStack</span><span class="p">.</span><span class="na">pop</span><span class="p">());</span><span class="w"> </span><span class="c1">//All that is needed is to pop the item at the top of the stack, which will contain the most recently encountered junction</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">popFinalRouteStack</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">(</span><span class="n">finalRouteStack</span><span class="p">.</span><span class="na">pop</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>


<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">createHeadingsHashMap</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="n">hashMapHeadings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="p">(){</span><span class="w"> </span><span class="c1">//Creates a hashmap with integers as the key (e.g. IRobot.NORTH) and string as the value (e.g. &#39;NORTH&#39;)</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">NORTH</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NORTH&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">EAST</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;EAST&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">SOUTH</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SOUTH&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">put</span><span class="p">(</span><span class="n">IRobot</span><span class="p">.</span><span class="na">WEST</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WEST&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">printStack</span><span class="p">(){</span><span class="w"> </span><span class="c1">//Print the final route stack</span><span class="w"></span>
<span class="w">        </span><span class="n">finalRouteStack</span><span class="p">.</span><span class="na">printStack</span><span class="p">(</span><span class="n">hashMapHeadings</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">retraceGetNextHeading</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">finalRouteStack</span><span class="p">.</span><span class="na">getElemFromStack</span><span class="p">(</span><span class="n">index</span><span class="p">));</span><span class="w"> </span><span class="c1">//Gets the heading from the final route stack at the specified index.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">class</span> <span class="nc">Stack</span><span class="p">{</span><span class="w"> </span><span class="c1">//stack that contains integer values</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Short</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stackList</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">stackSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Represents the number of elments in the stack.</span><span class="w"></span>

<span class="w">    </span><span class="n">Stack</span><span class="p">(){</span><span class="w"> </span><span class="c1">//Class constructor creates a new stackList.</span><span class="w"></span>
<span class="w">        </span><span class="n">stackList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Short</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">pop</span><span class="p">(){</span><span class="w"> </span><span class="c1">//pop top element from stack and returns that element</span><span class="w"></span>
<span class="w">        </span><span class="n">stackSize</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">//decrement stackSize</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">(</span><span class="n">stackList</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">stackSize</span><span class="p">));</span><span class="w"> </span><span class="c1">//remove the last element in the arrayList. Note: as stackSize has been decremented, remove at index stackSize, not stackSize - 1.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="kt">short</span><span class="w"> </span><span class="n">heading</span><span class="p">){</span><span class="w"> </span><span class="c1">//push a given heading ontop of the stack</span><span class="w"></span>
<span class="w">        </span><span class="n">stackList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">heading</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">stackSize</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//Increment stack size as a new element has been added to the arrayList</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">clearStack</span><span class="p">(){</span><span class="w"></span>
<span class="w">        </span><span class="n">stackSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Reset stack size to 0 as there are now no items in the arrayList.</span><span class="w"></span>
<span class="w">        </span><span class="n">stackList</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getElemFromStack</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">){</span><span class="w"> </span><span class="c1">//Gets element from stack at specified index.</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">stackList</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">index</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">printStack</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hashMapHeadings</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="s">&quot;Route: &quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">stackSize</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//Loops through elach element in the stack</span><span class="w"></span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">hashMapHeadings</span><span class="p">.</span><span class="na">get</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">stackList</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="c1">//Gets the corresponding string for the heading from the hash map and prints it.</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kd">class</span> <span class="nc">EventClient</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">IEventClient</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">GrandFinale</span><span class="w"> </span><span class="n">controller</span><span class="p">;</span><span class="w"> </span><span class="c1">//Holds the controller so that methods can be called.</span><span class="w"></span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">disallowedGenerators</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Set</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">LoopyGenerator</span><span class="p">().</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">(),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HillGenerator</span><span class="p">().</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">(),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BlankGenerator</span><span class="p">().</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="c1">//Set of maze generators that contain loops. If the user selects one of these generators, my program will output an appropriate warning message. (Cannot detect user added generators that contain loops)</span><span class="w"></span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">EventClient</span><span class="p">(</span><span class="n">GrandFinale</span><span class="w"> </span><span class="n">myController</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">controller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myController</span><span class="p">;</span><span class="w"> </span><span class="c1">//Set the controller instance when the EventClient class is instantiated.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nd">@Override</span><span class="w"></span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">notify</span><span class="p">(</span><span class="n">IEvent</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="w"> </span><span class="c1">//Overrides the IEventCient notify function so that my controller can get event messages.</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="na">getMessage</span><span class="p">();</span><span class="w"> </span><span class="c1">//Get the event message (event code)</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">msg</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">110</span><span class="p">){</span><span class="w"> </span><span class="c1">//Event code for when a new generator is loaded in</span><span class="w"></span>
<span class="w">            </span><span class="n">newGeneratorLoaded</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">disallowedGenerators</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">msg</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">107</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">115</span><span class="p">){</span><span class="w"> </span><span class="c1">//If the event code is 107(New Maze) or 115(Load Maze), reset variables and stacks.</span><span class="w"></span>
<span class="w">            </span><span class="n">newMazeLoaded</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">newMazeLoaded</span><span class="p">(){</span><span class="w"> </span><span class="c1">//When the user presses the New Maze or Load Maze button, all variables should be reset.</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">controller</span><span class="p">.</span><span class="na">resetFinalRoute</span><span class="p">();</span><span class="w"> </span><span class="c1">//If a new maze is created clear the finalRouteStack</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">controller</span><span class="p">.</span><span class="na">reset</span><span class="p">();</span><span class="w"> </span><span class="c1">//Also clear junctionStack and reset all variables</span><span class="w"></span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;New maze loaded. Resetting...&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">newGeneratorLoaded</span><span class="p">(</span><span class="n">IEvent</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">disallowedGenerators</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">IMazeGenerator</span><span class="w"> </span><span class="n">mazeGen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">IMazeGenerator</span><span class="p">)</span><span class="n">e</span><span class="p">.</span><span class="na">getData</span><span class="p">();</span><span class="w"> </span><span class="c1">//The data sent in the event is the new maze generator that will be used.</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">disallowedGenerators</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">mazeGen</span><span class="p">.</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">())){</span><span class="w"> </span><span class="c1">//If the new generator creates mazes with loops, the backtracking will not work.</span><span class="w"></span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Warning: this controller does not find the quickest route in mazes with loops!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>