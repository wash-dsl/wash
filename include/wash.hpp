/**
 * @file wash.hpp
 * @authors Wash Project Group
 * @brief The public facing API for all Wash programs to be written with
 * @version 0.1
 * @date 2024-02-12
 * 
 * @copyright Copyright (c) 2024
 * 
 * Implementations:
 *  - wash (-DWASH_WSER)     -- Basic serial implementation. Particle class owns all it's data, 
 *                              forces accessed though strings into per-particle map
 *  - wisb (-DWASH_WISB)     -- Data storage transformed from AoS to SoA. Particle class owns it's global ID (size_t wrapper),
 *                              Forces are accessed through a global map with particle index lookup
 *  - ws2st (-DWASH_WEST)    -- DSL translation removing string keys, the particles own their ID similar to WISB but forces are
 *                              accessed directly through particle idx (generated by translations)
 *  - cstone (-DWASH_CSTONE) -- Wash with multinode support. Particle class owns local and global ID (pair size_t),
 *                              Forces are accessed through global map with string lookups for indexing and per-particle indexing
 *  - wstone (-DWASH_WONE)   -- Integrating cornerstone into the ws2st implementation.
 * 
 * Dimensionality: 
 *  - Wash is a dimension agnostic API. Certain implementations have requirements due to technical reasons
 *  - The dimension of Simulation Vectors is controlled by the DIM define (-DDIM=d)
 */
#pragma once

// Ensure that the compilation stage has defined an implementation specific flag
// this is used to enable some optional parameters and features in e.g. the Particle class
// Usually the user should not see this message as the wash tool will define the appropriate flag for them.
#if !defined WASH_WSER && !defined WASH_WISB && !defined WASH_WEST && !defined WASH_CSTONE && !defined WASH_WONE
#error "Please specify an implementation when compiling WASH"
#endif 

// DIM is the compile-time flag for the dimensionality of the simulation, dictating
// the dimensionality of the vector to use. This should be specified in the implementation library.
#ifndef DIM
#error "Please define -DDIM=d when compiling WASH"
#endif

#include <chrono>
#include <cassert>
#include <chrono>
#include <functional>
#include <optional>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

#include "io.hpp"
#include "particle.hpp"
#include "particle_data.hpp"
#include "util.hpp"
#include "vector.hpp"
#include "kernels.hpp"

namespace wash {

    /**
     * @brief Get the max iterations of the simulation
     *
     * @return uint64_t
     */
    uint64_t get_max_iterations();

    /**
     * @brief Set the max number of iterations
     *
     * @param iterations
     */
    void set_max_iterations(const uint64_t iterations);

    /**
     *  @brief Set the bounding box dimensions and periodicity type 
     */
    void set_bounding_box(const double min, const double max, const bool periodic);

    /**
     *  @brief Set the bounding box dimensions and periodicity type in 3 dimensions
     */
    void set_bounding_box(const double xmin, const double xmax, const double ymin, const double ymax, const double zmin,
                          const double zmax, const bool x_periodic, const bool y_periodic, const bool z_periodic);

    /**
     * @brief Add a scalar force to the simulation
     *
     * @param force Name of the force
     */
    void add_force_scalar(const std::string force);

    /**
     * @brief Add a n-dim vector force to the simulation
     *
     * @param force Name of the force
     */
    void add_force_vector(const std::string force);

    /**
     * @brief Add a scalar variable to the simulation
     *
     * @param variable Name of the variable
     * @param init_value The initial value of the variable
     */
    void add_variable(const std::string variable, double init_value = 0.0);

    /**
     * @brief Add an initialisation update kernel (will be executed for each particle)
     * 
     * @param func Reference to the kernel function
     */
    void add_init_update_kernel(const UpdateFuncT func);

    /**
     * @brief Add an initialization void kernel to the simulation - run once
     *
     * @param func Reference to the kernel function
     */
    void add_init_void_kernel(const VoidFuncT func);

    /**
     * @brief Add a force kernel to the simulation which will loop over the particles
     * and their neighbourhood
     *
     * @param func Reference to the kernel function
     */
    void add_force_kernel(const ForceFuncT func);

    /**
     * @brief Add an update kernel to the simulation which will loop over the particles
     *
     * @param func Reference to the kernel function
     */
    void add_update_kernel(const UpdateFuncT func);

    /**
     * @brief Add a reduction kernel to the simulation which will loop over the particles.
     *
     * Extracts a value from each particle using `map_func`, then aggregates these values using `reduce_op`. 
     *     The result will be saved to `variable`.
     *
     * @param map_func Function to map each particle to
     * @param reduce_op The reduction operator type to use in the reduction
     * @param variable Variable to store the result in
     */
    void add_reduction_kernel(const MapFuncT map_func, const ReduceOp reduce_op, double* variable);

    /**
     * @brief Add a void kernel to the simulation
     *
     * @param func Reference to the kernel function
     */
    void add_void_kernel(const VoidFuncT func);

    /**
     * @brief Set the neighborhood search to use the provided default
     *        which uses the smoothing length of the particle and returns at most
     *        max_count neighbours.
     * 
     * @param max_count Maximum number of neighbours to return 
     */
    void set_default_neighbor_search(const unsigned max_count);

    /**
     * @brief Sets the neighbourhood search to use a custom function
     *
     * @param func Reference to the search function
     * @param max_count Maximum number of neighbours(?)
     */
    void set_neighbor_search_kernel(const NeighborsFuncT func, const unsigned max_count);

    /**
     * @brief Get the value of a variable
     *
     * @param variable Name of the variable
     * @return double
     */
    double get_variable(const std::string& variable);

    /**
     * @brief Returns a reference to a variable useful for e.g. reduction kernels
     * 
     * @param variable 
     * @return double*
     */
    double* use_variable(const std::string& variable);

    /**
     * @brief Set the value of a variable
     *
     * @param variable Name of the variable
     * @param value Value to set it to
     */
    void set_variable(const std::string& variable, const double value);

    /**
     * @brief Get the vector of all particles in the simulation
     *
     * @return std::vector<Particle>&
     */
    std::vector<Particle>& get_particles();

    /**
     * @brief Starts the simulation
     */
    void start();

    /**
     * @brief Set the name of the simulation, used in IO
     *
     * @param name Name to use
     */
    void set_simulation_name(const std::string name);

    /**
     * @brief Set the output file name of the simulation
     *
     * @param name Name to use
     */
    void set_output_file_name(const std::string name);

    /// TODO: Move eucdist calculation to the paticle header?
    /**
     * @brief Compute the euclidean distance between two particles
     *
     * @param p First particle
     * @param q Second particle
     * @return double
     */
    double eucdist(const Particle& p, const Particle& q);

    /**
     * @brief Set the number of particles to be used in the simulation
     *
     * @param count
     */
    void set_particle_count(const size_t count);

    /**
     * @brief Get the number of particles used in the simulation
     *
     * @return size_t
     */
    size_t get_particle_count();

    /**
     * @brief Set the dimensionality of the simulation
     * 
     * @param dim 2, or 3
     */
    void set_dimension(int dim);

    /**
     * @brief Set the IO parameters used for the simulation 
     */
    void set_io(const std::string format, size_t output_nth);
};
